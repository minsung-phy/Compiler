007:[CLASS] class
007:[TYPE] A
007:[LBRACE] {
009:[ID] var
009:[COLON] :
009:[TYPE] Int
009:[ASSIGN] <-
009:[INTEGER] 0
009:[SEMICOLON] ;
011:[ID] value
011:[LPAREN] (
011:[RPAREN] )
011:[COLON] :
011:[TYPE] Int
011:[LBRACE] {
011:[ID] var
011:[RBRACE] }
011:[SEMICOLON] ;
013:[ID] set_var
013:[LPAREN] (
013:[ID] num
013:[COLON] :
013:[TYPE] Int
013:[RPAREN] )
013:[COLON] :
013:[TYPE] SELF_TYPE
013:[LBRACE] {
014:[LBRACE] {
015:[ID] var
015:[ASSIGN] <-
015:[ID] num
015:[SEMICOLON] ;
016:[ID] self
016:[SEMICOLON] ;
017:[RBRACE] }
018:[RBRACE] }
018:[SEMICOLON] ;
020:[ID] method1
020:[LPAREN] (
020:[ID] num
020:[COLON] :
020:[TYPE] Int
020:[RPAREN] )
020:[COLON] :
020:[TYPE] SELF_TYPE
020:[LBRACE] {
021:[ID] self
022:[RBRACE] }
022:[SEMICOLON] ;
024:[ID] method2
024:[LPAREN] (
024:[ID] num1
024:[COLON] :
024:[TYPE] Int
024:[COMMA] ,
024:[ID] num2
024:[COLON] :
024:[TYPE] Int
024:[RPAREN] )
024:[COLON] :
024:[TYPE] B
024:[LBRACE] {
025:[LPAREN] (
025:[LET] let
025:[ID] x
025:[COLON] :
025:[TYPE] Int
025:[IN] in
026:[LBRACE] {
027:[ID] x
027:[ASSIGN] <-
027:[ID] num1
027:[PLUS] +
027:[ID] num2
027:[SEMICOLON] ;
028:[LPAREN] (
028:[NEW] new
028:[TYPE] B
028:[RPAREN] )
028:[DOT] .
028:[ID] set_var
028:[LPAREN] (
028:[ID] x
028:[RPAREN] )
028:[SEMICOLON] ;
029:[RBRACE] }
030:[RPAREN] )
031:[RBRACE] }
031:[SEMICOLON] ;
033:[ID] method3
033:[LPAREN] (
033:[ID] num
033:[COLON] :
033:[TYPE] Int
033:[RPAREN] )
033:[COLON] :
033:[TYPE] C
033:[LBRACE] {
034:[LPAREN] (
034:[LET] let
034:[ID] x
034:[COLON] :
034:[TYPE] Int
034:[IN] in
035:[LBRACE] {
036:[ID] x
036:[ASSIGN] <-
036:[NEG] ~
036:[ID] num
036:[SEMICOLON] ;
037:[LPAREN] (
037:[NEW] new
037:[TYPE] C
037:[RPAREN] )
037:[DOT] .
037:[ID] set_var
037:[LPAREN] (
037:[ID] x
037:[RPAREN] )
037:[SEMICOLON] ;
038:[RBRACE] }
039:[RPAREN] )
040:[RBRACE] }
040:[SEMICOLON] ;
042:[ID] method4
042:[LPAREN] (
042:[ID] num1
042:[COLON] :
042:[TYPE] Int
042:[COMMA] ,
042:[ID] num2
042:[COLON] :
042:[TYPE] Int
042:[RPAREN] )
042:[COLON] :
042:[TYPE] D
042:[LBRACE] {
043:[IF] if
043:[ID] num2
043:[LT] <
043:[ID] num1
043:[THEN] then
044:[LPAREN] (
044:[LET] let
044:[ID] x
044:[COLON] :
044:[TYPE] Int
044:[IN] in
045:[LBRACE] {
046:[ID] x
046:[ASSIGN] <-
046:[ID] num1
046:[MINUS] -
046:[ID] num2
046:[SEMICOLON] ;
047:[LPAREN] (
047:[NEW] new
047:[TYPE] D
047:[RPAREN] )
047:[DOT] .
047:[ID] set_var
047:[LPAREN] (
047:[ID] x
047:[RPAREN] )
047:[SEMICOLON] ;
048:[RBRACE] }
049:[RPAREN] )
050:[ELSE] else
051:[LPAREN] (
051:[LET] let
051:[ID] x
051:[COLON] :
051:[TYPE] Int
051:[IN] in
052:[LBRACE] {
053:[ID] x
053:[ASSIGN] <-
053:[ID] num2
053:[MINUS] -
053:[ID] num1
053:[SEMICOLON] ;
054:[LPAREN] (
054:[NEW] new
054:[TYPE] D
054:[RPAREN] )
054:[DOT] .
054:[ID] set_var
054:[LPAREN] (
054:[ID] x
054:[RPAREN] )
054:[SEMICOLON] ;
055:[RBRACE] }
056:[RPAREN] )
057:[FI] fi
058:[RBRACE] }
058:[SEMICOLON] ;
060:[ID] method5
060:[LPAREN] (
060:[ID] num
060:[COLON] :
060:[TYPE] Int
060:[RPAREN] )
060:[COLON] :
060:[TYPE] E
060:[LBRACE] {
061:[LPAREN] (
061:[LET] let
061:[ID] x
061:[COLON] :
061:[TYPE] Int
061:[ASSIGN] <-
061:[INTEGER] 1
061:[IN] in
062:[LBRACE] {
063:[LPAREN] (
063:[LET] let
063:[ID] y
063:[COLON] :
063:[TYPE] Int
063:[ASSIGN] <-
063:[INTEGER] 1
063:[IN] in
064:[WHILE] while
064:[ID] y
064:[LTE] <=
064:[ID] num
064:[LOOP] loop
065:[LBRACE] {
066:[ID] x
066:[ASSIGN] <-
066:[ID] x
066:[MUL] *
066:[ID] y
066:[SEMICOLON] ;
067:[ID] y
067:[ASSIGN] <-
067:[ID] y
067:[PLUS] +
067:[INTEGER] 1
067:[SEMICOLON] ;
068:[RBRACE] }
069:[POOL] pool
070:[RPAREN] )
070:[SEMICOLON] ;
071:[LPAREN] (
071:[NEW] new
071:[TYPE] E
071:[RPAREN] )
071:[DOT] .
071:[ID] set_var
071:[LPAREN] (
071:[ID] x
071:[RPAREN] )
071:[SEMICOLON] ;
072:[RBRACE] }
073:[RPAREN] )
074:[RBRACE] }
074:[SEMICOLON] ;
076:[RBRACE] }
076:[SEMICOLON] ;
078:[CLASS] class
078:[TYPE] B
078:[INHERITS] inherits
078:[TYPE] A
078:[LBRACE] {
080:[ID] method5
080:[LPAREN] (
080:[ID] num
080:[COLON] :
080:[TYPE] Int
080:[RPAREN] )
080:[COLON] :
080:[TYPE] E
080:[LBRACE] {
081:[LPAREN] (
081:[LET] let
081:[ID] x
081:[COLON] :
081:[TYPE] Int
081:[IN] in
082:[LBRACE] {
083:[ID] x
083:[ASSIGN] <-
083:[ID] num
083:[MUL] *
083:[ID] num
083:[SEMICOLON] ;
084:[LPAREN] (
084:[NEW] new
084:[TYPE] E
084:[RPAREN] )
084:[DOT] .
084:[ID] set_var
084:[LPAREN] (
084:[ID] x
084:[RPAREN] )
084:[SEMICOLON] ;
085:[RBRACE] }
086:[RPAREN] )
087:[RBRACE] }
087:[SEMICOLON] ;
089:[RBRACE] }
089:[SEMICOLON] ;
091:[CLASS] class
091:[TYPE] C
091:[INHERITS] inherits
091:[TYPE] B
091:[LBRACE] {
093:[ID] method6
093:[LPAREN] (
093:[ID] num
093:[COLON] :
093:[TYPE] Int
093:[RPAREN] )
093:[COLON] :
093:[TYPE] A
093:[LBRACE] {
094:[LPAREN] (
094:[LET] let
094:[ID] x
094:[COLON] :
094:[TYPE] Int
094:[IN] in
095:[LBRACE] {
096:[ID] x
096:[ASSIGN] <-
096:[NEG] ~
096:[ID] num
096:[SEMICOLON] ;
097:[LPAREN] (
097:[NEW] new
097:[TYPE] A
097:[RPAREN] )
097:[DOT] .
097:[ID] set_var
097:[LPAREN] (
097:[ID] x
097:[RPAREN] )
097:[SEMICOLON] ;
098:[RBRACE] }
099:[RPAREN] )
100:[RBRACE] }
100:[SEMICOLON] ;
102:[ID] method5
102:[LPAREN] (
102:[ID] num
102:[COLON] :
102:[TYPE] Int
102:[RPAREN] )
102:[COLON] :
102:[TYPE] E
102:[LBRACE] {
103:[LPAREN] (
103:[LET] let
103:[ID] x
103:[COLON] :
103:[TYPE] Int
103:[IN] in
104:[LBRACE] {
105:[ID] x
105:[ASSIGN] <-
105:[ID] num
105:[MUL] *
105:[ID] num
105:[MUL] *
105:[ID] num
105:[SEMICOLON] ;
106:[LPAREN] (
106:[NEW] new
106:[TYPE] E
106:[RPAREN] )
106:[DOT] .
106:[ID] set_var
106:[LPAREN] (
106:[ID] x
106:[RPAREN] )
106:[SEMICOLON] ;
107:[RBRACE] }
108:[RPAREN] )
109:[RBRACE] }
109:[SEMICOLON] ;
111:[RBRACE] }
111:[SEMICOLON] ;
113:[CLASS] class
113:[TYPE] D
113:[INHERITS] inherits
113:[TYPE] B
113:[LBRACE] {
115:[ID] method7
115:[LPAREN] (
115:[ID] num
115:[COLON] :
115:[TYPE] Int
115:[RPAREN] )
115:[COLON] :
115:[TYPE] Bool
115:[LBRACE] {
116:[LPAREN] (
116:[LET] let
116:[ID] x
116:[COLON] :
116:[TYPE] Int
116:[ASSIGN] <-
116:[ID] num
116:[IN] in
117:[IF] if
117:[ID] x
117:[LT] <
117:[INTEGER] 0
117:[THEN] then
117:[ID] method7
117:[LPAREN] (
117:[NEG] ~
117:[ID] x
117:[RPAREN] )
117:[ELSE] else
118:[IF] if
118:[INTEGER] 0
118:[EQUAL] =
118:[ID] x
118:[THEN] then
118:[TRUE] true
118:[ELSE] else
119:[IF] if
119:[INTEGER] 1
119:[EQUAL] =
119:[ID] x
119:[THEN] then
119:[FALSE] false
119:[ELSE] else
120:[IF] if
120:[INTEGER] 2
120:[EQUAL] =
120:[ID] x
120:[THEN] then
120:[FALSE] false
120:[ELSE] else
121:[ID] method7
121:[LPAREN] (
121:[ID] x
121:[MINUS] -
121:[INTEGER] 3
121:[RPAREN] )
122:[FI] fi
122:[FI] fi
122:[FI] fi
122:[FI] fi
123:[RPAREN] )
124:[RBRACE] }
124:[SEMICOLON] ;
126:[RBRACE] }
126:[SEMICOLON] ;
128:[CLASS] class
128:[TYPE] E
128:[INHERITS] inherits
128:[TYPE] D
128:[LBRACE] {
130:[ID] method6
130:[LPAREN] (
130:[ID] num
130:[COLON] :
130:[TYPE] Int
130:[RPAREN] )
130:[COLON] :
130:[TYPE] A
130:[LBRACE] {
131:[LPAREN] (
131:[LET] let
131:[ID] x
131:[COLON] :
131:[TYPE] Int
131:[IN] in
132:[LBRACE] {
133:[ID] x
133:[ASSIGN] <-
133:[ID] num
133:[DIV] /
133:[INTEGER] 8
133:[SEMICOLON] ;
134:[LPAREN] (
134:[NEW] new
134:[TYPE] A
134:[RPAREN] )
134:[DOT] .
134:[ID] set_var
134:[LPAREN] (
134:[ID] x
134:[RPAREN] )
134:[SEMICOLON] ;
135:[RBRACE] }
136:[RPAREN] )
137:[RBRACE] }
137:[SEMICOLON] ;
139:[RBRACE] }
139:[SEMICOLON] ;
155:[CLASS] class
155:[TYPE] A2I
155:[LBRACE] {
157:[ID] c2i
157:[LPAREN] (
157:[ID] char
157:[COLON] :
157:[TYPE] String
157:[RPAREN] )
157:[COLON] :
157:[TYPE] Int
157:[LBRACE] {
158:[IF] if
158:[ID] char
158:[EQUAL] =
158:[STRING] "0"
158:[THEN] then
158:[INTEGER] 0
158:[ELSE] else
159:[IF] if
159:[ID] char
159:[EQUAL] =
159:[STRING] "1"
159:[THEN] then
159:[INTEGER] 1
159:[ELSE] else
160:[IF] if
160:[ID] char
160:[EQUAL] =
160:[STRING] "2"
160:[THEN] then
160:[INTEGER] 2
160:[ELSE] else
161:[IF] if
161:[ID] char
161:[EQUAL] =
161:[STRING] "3"
161:[THEN] then
161:[INTEGER] 3
161:[ELSE] else
162:[IF] if
162:[ID] char
162:[EQUAL] =
162:[STRING] "4"
162:[THEN] then
162:[INTEGER] 4
162:[ELSE] else
163:[IF] if
163:[ID] char
163:[EQUAL] =
163:[STRING] "5"
163:[THEN] then
163:[INTEGER] 5
163:[ELSE] else
164:[IF] if
164:[ID] char
164:[EQUAL] =
164:[STRING] "6"
164:[THEN] then
164:[INTEGER] 6
164:[ELSE] else
165:[IF] if
165:[ID] char
165:[EQUAL] =
165:[STRING] "7"
165:[THEN] then
165:[INTEGER] 7
165:[ELSE] else
166:[IF] if
166:[ID] char
166:[EQUAL] =
166:[STRING] "8"
166:[THEN] then
166:[INTEGER] 8
166:[ELSE] else
167:[IF] if
167:[ID] char
167:[EQUAL] =
167:[STRING] "9"
167:[THEN] then
167:[INTEGER] 9
167:[ELSE] else
168:[LBRACE] {
168:[ID] abort
168:[LPAREN] (
168:[RPAREN] )
168:[SEMICOLON] ;
168:[INTEGER] 0
168:[SEMICOLON] ;
168:[RBRACE] }
170:[FI] fi
170:[FI] fi
170:[FI] fi
170:[FI] fi
170:[FI] fi
170:[FI] fi
170:[FI] fi
170:[FI] fi
170:[FI] fi
170:[FI] fi
171:[RBRACE] }
171:[SEMICOLON] ;
176:[ID] i2c
176:[LPAREN] (
176:[ID] i
176:[COLON] :
176:[TYPE] Int
176:[RPAREN] )
176:[COLON] :
176:[TYPE] String
176:[LBRACE] {
177:[IF] if
177:[ID] i
177:[EQUAL] =
177:[INTEGER] 0
177:[THEN] then
177:[STRING] "0"
177:[ELSE] else
178:[IF] if
178:[ID] i
178:[EQUAL] =
178:[INTEGER] 1
178:[THEN] then
178:[STRING] "1"
178:[ELSE] else
179:[IF] if
179:[ID] i
179:[EQUAL] =
179:[INTEGER] 2
179:[THEN] then
179:[STRING] "2"
179:[ELSE] else
180:[IF] if
180:[ID] i
180:[EQUAL] =
180:[INTEGER] 3
180:[THEN] then
180:[STRING] "3"
180:[ELSE] else
181:[IF] if
181:[ID] i
181:[EQUAL] =
181:[INTEGER] 4
181:[THEN] then
181:[STRING] "4"
181:[ELSE] else
182:[IF] if
182:[ID] i
182:[EQUAL] =
182:[INTEGER] 5
182:[THEN] then
182:[STRING] "5"
182:[ELSE] else
183:[IF] if
183:[ID] i
183:[EQUAL] =
183:[INTEGER] 6
183:[THEN] then
183:[STRING] "6"
183:[ELSE] else
184:[IF] if
184:[ID] i
184:[EQUAL] =
184:[INTEGER] 7
184:[THEN] then
184:[STRING] "7"
184:[ELSE] else
185:[IF] if
185:[ID] i
185:[EQUAL] =
185:[INTEGER] 8
185:[THEN] then
185:[STRING] "8"
185:[ELSE] else
186:[IF] if
186:[ID] i
186:[EQUAL] =
186:[INTEGER] 9
186:[THEN] then
186:[STRING] "9"
186:[ELSE] else
187:[LBRACE] {
187:[ID] abort
187:[LPAREN] (
187:[RPAREN] )
187:[SEMICOLON] ;
187:[STRING] ""
187:[SEMICOLON] ;
187:[RBRACE] }
188:[FI] fi
188:[FI] fi
188:[FI] fi
188:[FI] fi
188:[FI] fi
188:[FI] fi
188:[FI] fi
188:[FI] fi
188:[FI] fi
188:[FI] fi
189:[RBRACE] }
189:[SEMICOLON] ;
199:[ID] a2i
199:[LPAREN] (
199:[ID] s
199:[COLON] :
199:[TYPE] String
199:[RPAREN] )
199:[COLON] :
199:[TYPE] Int
199:[LBRACE] {
200:[IF] if
200:[ID] s
200:[DOT] .
200:[ID] length
200:[LPAREN] (
200:[RPAREN] )
200:[EQUAL] =
200:[INTEGER] 0
200:[THEN] then
200:[INTEGER] 0
200:[ELSE] else
201:[IF] if
201:[ID] s
201:[DOT] .
201:[ID] substr
201:[LPAREN] (
201:[INTEGER] 0
201:[COMMA] ,
201:[INTEGER] 1
201:[RPAREN] )
201:[EQUAL] =
201:[STRING] "-"
201:[THEN] then
201:[NEG] ~
201:[ID] a2i_aux
201:[LPAREN] (
201:[ID] s
201:[DOT] .
201:[ID] substr
201:[LPAREN] (
201:[INTEGER] 1
201:[COMMA] ,
201:[ID] s
201:[DOT] .
201:[ID] length
201:[LPAREN] (
201:[RPAREN] )
201:[MINUS] -
201:[INTEGER] 1
201:[RPAREN] )
201:[RPAREN] )
201:[ELSE] else
202:[IF] if
202:[ID] s
202:[DOT] .
202:[ID] substr
202:[LPAREN] (
202:[INTEGER] 0
202:[COMMA] ,
202:[INTEGER] 1
202:[RPAREN] )
202:[EQUAL] =
202:[STRING] "+"
202:[THEN] then
202:[ID] a2i_aux
202:[LPAREN] (
202:[ID] s
202:[DOT] .
202:[ID] substr
202:[LPAREN] (
202:[INTEGER] 1
202:[COMMA] ,
202:[ID] s
202:[DOT] .
202:[ID] length
202:[LPAREN] (
202:[RPAREN] )
202:[MINUS] -
202:[INTEGER] 1
202:[RPAREN] )
202:[RPAREN] )
202:[ELSE] else
203:[ID] a2i_aux
203:[LPAREN] (
203:[ID] s
203:[RPAREN] )
204:[FI] fi
204:[FI] fi
204:[FI] fi
205:[RBRACE] }
205:[SEMICOLON] ;
211:[ID] a2i_aux
211:[LPAREN] (
211:[ID] s
211:[COLON] :
211:[TYPE] String
211:[RPAREN] )
211:[COLON] :
211:[TYPE] Int
211:[LBRACE] {
212:[LPAREN] (
212:[LET] let
212:[ID] int
212:[COLON] :
212:[TYPE] Int
212:[ASSIGN] <-
212:[INTEGER] 0
212:[IN] in
213:[LBRACE] {
214:[LPAREN] (
214:[LET] let
214:[ID] j
214:[COLON] :
214:[TYPE] Int
214:[ASSIGN] <-
214:[ID] s
214:[DOT] .
214:[ID] length
214:[LPAREN] (
214:[RPAREN] )
214:[IN] in
215:[LPAREN] (
215:[LET] let
215:[ID] i
215:[COLON] :
215:[TYPE] Int
215:[ASSIGN] <-
215:[INTEGER] 0
215:[IN] in
216:[WHILE] while
216:[ID] i
216:[LT] <
216:[ID] j
216:[LOOP] loop
217:[LBRACE] {
218:[ID] int
218:[ASSIGN] <-
218:[ID] int
218:[MUL] *
218:[INTEGER] 10
218:[PLUS] +
218:[ID] c2i
218:[LPAREN] (
218:[ID] s
218:[DOT] .
218:[ID] substr
218:[LPAREN] (
218:[ID] i
218:[COMMA] ,
218:[INTEGER] 1
218:[RPAREN] )
218:[RPAREN] )
218:[SEMICOLON] ;
219:[ID] i
219:[ASSIGN] <-
219:[ID] i
219:[PLUS] +
219:[INTEGER] 1
219:[SEMICOLON] ;
220:[RBRACE] }
221:[POOL] pool
222:[RPAREN] )
223:[RPAREN] )
223:[SEMICOLON] ;
224:[ID] int
224:[SEMICOLON] ;
225:[RBRACE] }
226:[RPAREN] )
227:[RBRACE] }
227:[SEMICOLON] ;
232:[ID] i2a
232:[LPAREN] (
232:[ID] i
232:[COLON] :
232:[TYPE] Int
232:[RPAREN] )
232:[COLON] :
232:[TYPE] String
232:[LBRACE] {
233:[IF] if
233:[ID] i
233:[EQUAL] =
233:[INTEGER] 0
233:[THEN] then
233:[STRING] "0"
233:[ELSE] else
234:[IF] if
234:[INTEGER] 0
234:[LT] <
234:[ID] i
234:[THEN] then
234:[ID] i2a_aux
234:[LPAREN] (
234:[ID] i
234:[RPAREN] )
234:[ELSE] else
235:[STRING] "-"
235:[DOT] .
235:[ID] concat
235:[LPAREN] (
235:[ID] i2a_aux
235:[LPAREN] (
235:[ID] i
235:[MUL] *
235:[NEG] ~
235:[INTEGER] 1
235:[RPAREN] )
235:[RPAREN] )
236:[FI] fi
236:[FI] fi
237:[RBRACE] }
237:[SEMICOLON] ;
241:[ID] i2a_aux
241:[LPAREN] (
241:[ID] i
241:[COLON] :
241:[TYPE] Int
241:[RPAREN] )
241:[COLON] :
241:[TYPE] String
241:[LBRACE] {
242:[IF] if
242:[ID] i
242:[EQUAL] =
242:[INTEGER] 0
242:[THEN] then
242:[STRING] ""
242:[ELSE] else
243:[LPAREN] (
243:[LET] let
243:[ID] next
243:[COLON] :
243:[TYPE] Int
243:[ASSIGN] <-
243:[ID] i
243:[DIV] /
243:[INTEGER] 10
243:[IN] in
244:[ID] i2a_aux
244:[LPAREN] (
244:[ID] next
244:[RPAREN] )
244:[DOT] .
244:[ID] concat
244:[LPAREN] (
244:[ID] i2c
244:[LPAREN] (
244:[ID] i
244:[MINUS] -
244:[ID] next
244:[MUL] *
244:[INTEGER] 10
244:[RPAREN] )
244:[RPAREN] )
245:[RPAREN] )
246:[FI] fi
247:[RBRACE] }
247:[SEMICOLON] ;
249:[RBRACE] }
249:[SEMICOLON] ;
251:[CLASS] class
251:[TYPE] Main
251:[INHERITS] inherits
251:[TYPE] IO
251:[LBRACE] {
253:[ID] char
253:[COLON] :
253:[TYPE] String
253:[SEMICOLON] ;
254:[ID] avar
254:[COLON] :
254:[TYPE] A
254:[SEMICOLON] ;
255:[ID] a_var
255:[COLON] :
255:[TYPE] A
255:[SEMICOLON] ;
256:[ID] flag
256:[COLON] :
256:[TYPE] Bool
256:[ASSIGN] <-
256:[TRUE] true
256:[SEMICOLON] ;
259:[ID] menu
259:[LPAREN] (
259:[RPAREN] )
259:[COLON] :
259:[TYPE] String
259:[LBRACE] {
260:[LBRACE] {
261:[ID] out_string
261:[LPAREN] (
261:[STRING] "\n\tTo add a number to "
261:[RPAREN] )
261:[SEMICOLON] ;
262:[ID] print
262:[LPAREN] (
262:[ID] avar
262:[RPAREN] )
262:[SEMICOLON] ;
263:[ID] out_string
263:[LPAREN] (
263:[STRING] "...enter a:\n"
263:[RPAREN] )
263:[SEMICOLON] ;
264:[ID] out_string
264:[LPAREN] (
264:[STRING] "\tTo negate "
264:[RPAREN] )
264:[SEMICOLON] ;
265:[ID] print
265:[LPAREN] (
265:[ID] avar
265:[RPAREN] )
265:[SEMICOLON] ;
266:[ID] out_string
266:[LPAREN] (
266:[STRING] "...enter b:\n"
266:[RPAREN] )
266:[SEMICOLON] ;
267:[ID] out_string
267:[LPAREN] (
267:[STRING] "\tTo find the difference between "
267:[RPAREN] )
267:[SEMICOLON] ;
268:[ID] print
268:[LPAREN] (
268:[ID] avar
268:[RPAREN] )
268:[SEMICOLON] ;
269:[ID] out_string
269:[LPAREN] (
269:[STRING] "and another number...enter c:\n"
269:[RPAREN] )
269:[SEMICOLON] ;
270:[ID] out_string
270:[LPAREN] (
270:[STRING] "\tTo find the factorial of "
270:[RPAREN] )
270:[SEMICOLON] ;
271:[ID] print
271:[LPAREN] (
271:[ID] avar
271:[RPAREN] )
271:[SEMICOLON] ;
272:[ID] out_string
272:[LPAREN] (
272:[STRING] "...enter d:\n"
272:[RPAREN] )
272:[SEMICOLON] ;
273:[ID] out_string
273:[LPAREN] (
273:[STRING] "\tTo square "
273:[RPAREN] )
273:[SEMICOLON] ;
274:[ID] print
274:[LPAREN] (
274:[ID] avar
274:[RPAREN] )
274:[SEMICOLON] ;
275:[ID] out_string
275:[LPAREN] (
275:[STRING] "...enter e:\n"
275:[RPAREN] )
275:[SEMICOLON] ;
276:[ID] out_string
276:[LPAREN] (
276:[STRING] "\tTo cube "
276:[RPAREN] )
276:[SEMICOLON] ;
277:[ID] print
277:[LPAREN] (
277:[ID] avar
277:[RPAREN] )
277:[SEMICOLON] ;
278:[ID] out_string
278:[LPAREN] (
278:[STRING] "...enter f:\n"
278:[RPAREN] )
278:[SEMICOLON] ;
279:[ID] out_string
279:[LPAREN] (
279:[STRING] "\tTo find out if "
279:[RPAREN] )
279:[SEMICOLON] ;
280:[ID] print
280:[LPAREN] (
280:[ID] avar
280:[RPAREN] )
280:[SEMICOLON] ;
281:[ID] out_string
281:[LPAREN] (
281:[STRING] "is a multiple of 3...enter g:\n"
281:[RPAREN] )
281:[SEMICOLON] ;
282:[ID] out_string
282:[LPAREN] (
282:[STRING] "\tTo divide "
282:[RPAREN] )
282:[SEMICOLON] ;
283:[ID] print
283:[LPAREN] (
283:[ID] avar
283:[RPAREN] )
283:[SEMICOLON] ;
284:[ID] out_string
284:[LPAREN] (
284:[STRING] "by 8...enter h:\n"
284:[RPAREN] )
284:[SEMICOLON] ;
285:[ID] out_string
285:[LPAREN] (
285:[STRING] "\tTo get a new number...enter j:\n"
285:[RPAREN] )
285:[SEMICOLON] ;
286:[ID] out_string
286:[LPAREN] (
286:[STRING] "\tTo quit...enter q:\n\n"
286:[RPAREN] )
286:[SEMICOLON] ;
287:[ID] in_string
287:[LPAREN] (
287:[RPAREN] )
287:[SEMICOLON] ;
288:[RBRACE] }
289:[RBRACE] }
289:[SEMICOLON] ;
291:[ID] prompt
291:[LPAREN] (
291:[RPAREN] )
291:[COLON] :
291:[TYPE] String
291:[LBRACE] {
292:[LBRACE] {
293:[ID] out_string
293:[LPAREN] (
293:[STRING] "\n"
293:[RPAREN] )
293:[SEMICOLON] ;
294:[ID] out_string
294:[LPAREN] (
294:[STRING] "Please enter a number...  "
294:[RPAREN] )
294:[SEMICOLON] ;
295:[ID] in_string
295:[LPAREN] (
295:[RPAREN] )
295:[SEMICOLON] ;
296:[RBRACE] }
297:[RBRACE] }
297:[SEMICOLON] ;
299:[ID] get_int
299:[LPAREN] (
299:[RPAREN] )
299:[COLON] :
299:[TYPE] Int
299:[LBRACE] {
300:[LBRACE] {
301:[LPAREN] (
301:[LET] let
301:[ID] z
301:[COLON] :
301:[TYPE] A2I
301:[ASSIGN] <-
301:[NEW] new
301:[TYPE] A2I
301:[IN] in
302:[LPAREN] (
302:[LET] let
302:[ID] s
302:[COLON] :
302:[TYPE] String
302:[ASSIGN] <-
302:[ID] prompt
302:[LPAREN] (
302:[RPAREN] )
302:[IN] in
303:[ID] z
303:[DOT] .
303:[ID] a2i
303:[LPAREN] (
303:[ID] s
303:[RPAREN] )
304:[RPAREN] )
305:[RPAREN] )
305:[SEMICOLON] ;
306:[RBRACE] }
307:[RBRACE] }
307:[SEMICOLON] ;
309:[ID] is_even
309:[LPAREN] (
309:[ID] num
309:[COLON] :
309:[TYPE] Int
309:[RPAREN] )
309:[COLON] :
309:[TYPE] Bool
309:[LBRACE] {
310:[LPAREN] (
310:[LET] let
310:[ID] x
310:[COLON] :
310:[TYPE] Int
310:[ASSIGN] <-
310:[ID] num
310:[IN] in
311:[IF] if
311:[ID] x
311:[LT] <
311:[INTEGER] 0
311:[THEN] then
311:[ID] is_even
311:[LPAREN] (
311:[NEG] ~
311:[ID] x
311:[RPAREN] )
311:[ELSE] else
312:[IF] if
312:[INTEGER] 0
312:[EQUAL] =
312:[ID] x
312:[THEN] then
312:[TRUE] true
312:[ELSE] else
313:[IF] if
313:[INTEGER] 1
313:[EQUAL] =
313:[ID] x
313:[THEN] then
313:[FALSE] false
313:[ELSE] else
314:[ID] is_even
314:[LPAREN] (
314:[ID] x
314:[MINUS] -
314:[INTEGER] 2
314:[RPAREN] )
315:[FI] fi
315:[FI] fi
315:[FI] fi
316:[RPAREN] )
317:[RBRACE] }
317:[SEMICOLON] ;
319:[ID] class_type
319:[LPAREN] (
319:[ID] var
319:[COLON] :
319:[TYPE] A
319:[RPAREN] )
319:[COLON] :
319:[TYPE] SELF_TYPE
319:[LBRACE] {
320:[CASE] case
320:[ID] var
320:[OF] of
321:[ID] a
321:[COLON] :
321:[TYPE] A
321:[DARROW] =>
321:[ID] out_string
321:[LPAREN] (
321:[STRING] "Class type is now A\n"
321:[RPAREN] )
321:[SEMICOLON] ;
322:[ID] b
322:[COLON] :
322:[TYPE] B
322:[DARROW] =>
322:[ID] out_string
322:[LPAREN] (
322:[STRING] "Class type is now B\n"
322:[RPAREN] )
322:[SEMICOLON] ;
323:[ID] c
323:[COLON] :
323:[TYPE] C
323:[DARROW] =>
323:[ID] out_string
323:[LPAREN] (
323:[STRING] "Class type is now C\n"
323:[RPAREN] )
323:[SEMICOLON] ;
324:[ID] d
324:[COLON] :
324:[TYPE] D
324:[DARROW] =>
324:[ID] out_string
324:[LPAREN] (
324:[STRING] "Class type is now D\n"
324:[RPAREN] )
324:[SEMICOLON] ;
325:[ID] e
325:[COLON] :
325:[TYPE] E
325:[DARROW] =>
325:[ID] out_string
325:[LPAREN] (
325:[STRING] "Class type is now E\n"
325:[RPAREN] )
325:[SEMICOLON] ;
326:[ID] o
326:[COLON] :
326:[TYPE] Object
326:[DARROW] =>
326:[ID] out_string
326:[LPAREN] (
326:[STRING] "Oooops\n"
326:[RPAREN] )
326:[SEMICOLON] ;
327:[ESAC] esac
328:[RBRACE] }
328:[SEMICOLON] ;
330:[ID] print
330:[LPAREN] (
330:[ID] var
330:[COLON] :
330:[TYPE] A
330:[RPAREN] )
330:[COLON] :
330:[TYPE] SELF_TYPE
330:[LBRACE] {
331:[LPAREN] (
331:[LET] let
331:[ID] z
331:[COLON] :
331:[TYPE] A2I
331:[ASSIGN] <-
331:[NEW] new
331:[TYPE] A2I
331:[IN] in
332:[LBRACE] {
333:[ID] out_string
333:[LPAREN] (
333:[ID] z
333:[DOT] .
333:[ID] i2a
333:[LPAREN] (
333:[ID] var
333:[DOT] .
333:[ID] value
333:[LPAREN] (
333:[RPAREN] )
333:[RPAREN] )
333:[RPAREN] )
333:[SEMICOLON] ;
334:[ID] out_string
334:[LPAREN] (
334:[STRING] " "
334:[RPAREN] )
334:[SEMICOLON] ;
335:[RBRACE] }
336:[RPAREN] )
337:[RBRACE] }
337:[SEMICOLON] ;
339:[ID] main
339:[LPAREN] (
339:[RPAREN] )
339:[COLON] :
339:[TYPE] Object
339:[LBRACE] {
340:[LBRACE] {
341:[ID] avar
341:[ASSIGN] <-
341:[LPAREN] (
341:[NEW] new
341:[TYPE] A
341:[RPAREN] )
341:[SEMICOLON] ;
342:[WHILE] while
342:[ID] flag
342:[LOOP] loop
343:[LBRACE] {
345:[ID] out_string
345:[LPAREN] (
345:[STRING] "number "
345:[RPAREN] )
345:[SEMICOLON] ;
346:[ID] print
346:[LPAREN] (
346:[ID] avar
346:[RPAREN] )
346:[SEMICOLON] ;
347:[IF] if
347:[ID] is_even
347:[LPAREN] (
347:[ID] avar
347:[DOT] .
347:[ID] value
347:[LPAREN] (
347:[RPAREN] )
347:[RPAREN] )
347:[THEN] then
348:[ID] out_string
348:[LPAREN] (
348:[STRING] "is even!\n"
348:[RPAREN] )
349:[ELSE] else
350:[ID] out_string
350:[LPAREN] (
350:[STRING] "is odd!\n"
350:[RPAREN] )
351:[FI] fi
351:[SEMICOLON] ;
353:[ID] class_type
353:[LPAREN] (
353:[ID] avar
353:[RPAREN] )
353:[SEMICOLON] ;
354:[ID] char
354:[ASSIGN] <-
354:[ID] menu
354:[LPAREN] (
354:[RPAREN] )
354:[SEMICOLON] ;
355:[IF] if
355:[ID] char
355:[EQUAL] =
355:[STRING] "a"
355:[THEN] then
356:[LBRACE] {
357:[ID] a_var
357:[ASSIGN] <-
357:[LPAREN] (
357:[NEW] new
357:[TYPE] A
357:[RPAREN] )
357:[DOT] .
357:[ID] set_var
357:[LPAREN] (
357:[ID] get_int
357:[LPAREN] (
357:[RPAREN] )
357:[RPAREN] )
357:[SEMICOLON] ;
358:[ID] avar
358:[ASSIGN] <-
358:[LPAREN] (
358:[NEW] new
358:[TYPE] B
358:[RPAREN] )
358:[DOT] .
358:[ID] method2
358:[LPAREN] (
358:[ID] avar
358:[DOT] .
358:[ID] value
358:[LPAREN] (
358:[RPAREN] )
358:[COMMA] ,
358:[ID] a_var
358:[DOT] .
358:[ID] value
358:[LPAREN] (
358:[RPAREN] )
358:[RPAREN] )
358:[SEMICOLON] ;
359:[RBRACE] }
359:[ELSE] else
360:[IF] if
360:[ID] char
360:[EQUAL] =
360:[STRING] "b"
360:[THEN] then
361:[CASE] case
361:[ID] avar
361:[OF] of
362:[ID] c
362:[COLON] :
362:[TYPE] C
362:[DARROW] =>
362:[ID] avar
362:[ASSIGN] <-
362:[ID] c
362:[DOT] .
362:[ID] method6
362:[LPAREN] (
362:[ID] c
362:[DOT] .
362:[ID] value
362:[LPAREN] (
362:[RPAREN] )
362:[RPAREN] )
362:[SEMICOLON] ;
363:[ID] a
363:[COLON] :
363:[TYPE] A
363:[DARROW] =>
363:[ID] avar
363:[ASSIGN] <-
363:[ID] a
363:[DOT] .
363:[ID] method3
363:[LPAREN] (
363:[ID] a
363:[DOT] .
363:[ID] value
363:[LPAREN] (
363:[RPAREN] )
363:[RPAREN] )
363:[SEMICOLON] ;
364:[ID] o
364:[COLON] :
364:[TYPE] Object
364:[DARROW] =>
364:[LBRACE] {
365:[ID] out_string
365:[LPAREN] (
365:[STRING] "Oooops\n"
365:[RPAREN] )
365:[SEMICOLON] ;
366:[ID] abort
366:[LPAREN] (
366:[RPAREN] )
366:[SEMICOLON] ;
366:[INTEGER] 0
366:[SEMICOLON] ;
367:[RBRACE] }
367:[SEMICOLON] ;
368:[ESAC] esac
368:[ELSE] else
369:[IF] if
369:[ID] char
369:[EQUAL] =
369:[STRING] "c"
369:[THEN] then
370:[LBRACE] {
371:[ID] a_var
371:[ASSIGN] <-
371:[LPAREN] (
371:[NEW] new
371:[TYPE] A
371:[RPAREN] )
371:[DOT] .
371:[ID] set_var
371:[LPAREN] (
371:[ID] get_int
371:[LPAREN] (
371:[RPAREN] )
371:[RPAREN] )
371:[SEMICOLON] ;
372:[ID] avar
372:[ASSIGN] <-
372:[LPAREN] (
372:[NEW] new
372:[TYPE] D
372:[RPAREN] )
372:[DOT] .
372:[ID] method4
372:[LPAREN] (
372:[ID] avar
372:[DOT] .
372:[ID] value
372:[LPAREN] (
372:[RPAREN] )
372:[COMMA] ,
372:[ID] a_var
372:[DOT] .
372:[ID] value
372:[LPAREN] (
372:[RPAREN] )
372:[RPAREN] )
372:[SEMICOLON] ;
373:[RBRACE] }
373:[ELSE] else
374:[IF] if
374:[ID] char
374:[EQUAL] =
374:[STRING] "d"
374:[THEN] then
374:[ID] avar
374:[ASSIGN] <-
374:[LPAREN] (
374:[NEW] new
374:[TYPE] C
374:[RPAREN] )
374:[ATSIGN] @
374:[TYPE] A
374:[DOT] .
374:[ID] method5
374:[LPAREN] (
374:[ID] avar
374:[DOT] .
374:[ID] value
374:[LPAREN] (
374:[RPAREN] )
374:[RPAREN] )
374:[ELSE] else
376:[IF] if
376:[ID] char
376:[EQUAL] =
376:[STRING] "e"
376:[THEN] then
376:[ID] avar
376:[ASSIGN] <-
376:[LPAREN] (
376:[NEW] new
376:[TYPE] C
376:[RPAREN] )
376:[ATSIGN] @
376:[TYPE] B
376:[DOT] .
376:[ID] method5
376:[LPAREN] (
376:[ID] avar
376:[DOT] .
376:[ID] value
376:[LPAREN] (
376:[RPAREN] )
376:[RPAREN] )
376:[ELSE] else
378:[IF] if
378:[ID] char
378:[EQUAL] =
378:[STRING] "f"
378:[THEN] then
378:[ID] avar
378:[ASSIGN] <-
378:[LPAREN] (
378:[NEW] new
378:[TYPE] C
378:[RPAREN] )
378:[ATSIGN] @
378:[TYPE] C
378:[DOT] .
378:[ID] method5
378:[LPAREN] (
378:[ID] avar
378:[DOT] .
378:[ID] value
378:[LPAREN] (
378:[RPAREN] )
378:[RPAREN] )
378:[ELSE] else
380:[IF] if
380:[ID] char
380:[EQUAL] =
380:[STRING] "g"
380:[THEN] then
381:[IF] if
381:[LPAREN] (
381:[LPAREN] (
381:[NEW] new
381:[TYPE] D
381:[RPAREN] )
381:[DOT] .
381:[ID] method7
381:[LPAREN] (
381:[ID] avar
381:[DOT] .
381:[ID] value
381:[LPAREN] (
381:[RPAREN] )
381:[RPAREN] )
381:[RPAREN] )
382:[THEN] then
383:[LBRACE] {
384:[ID] out_string
384:[LPAREN] (
384:[STRING] "number "
384:[RPAREN] )
384:[SEMICOLON] ;
385:[ID] print
385:[LPAREN] (
385:[ID] avar
385:[RPAREN] )
385:[SEMICOLON] ;
386:[ID] out_string
386:[LPAREN] (
386:[STRING] "is divisible by 3.\n"
386:[RPAREN] )
386:[SEMICOLON] ;
387:[RBRACE] }
388:[ELSE] else
389:[LBRACE] {
390:[ID] out_string
390:[LPAREN] (
390:[STRING] "number "
390:[RPAREN] )
390:[SEMICOLON] ;
391:[ID] print
391:[LPAREN] (
391:[ID] avar
391:[RPAREN] )
391:[SEMICOLON] ;
392:[ID] out_string
392:[LPAREN] (
392:[STRING] "is not divisible by 3.\n"
392:[RPAREN] )
392:[SEMICOLON] ;
393:[RBRACE] }
394:[FI] fi
394:[ELSE] else
395:[IF] if
395:[ID] char
395:[EQUAL] =
395:[STRING] "h"
395:[THEN] then
396:[LPAREN] (
396:[LET] let
396:[ID] x
396:[COLON] :
396:[TYPE] A
396:[IN] in
397:[LBRACE] {
398:[ID] x
398:[ASSIGN] <-
398:[LPAREN] (
398:[NEW] new
398:[TYPE] E
398:[RPAREN] )
398:[DOT] .
398:[ID] method6
398:[LPAREN] (
398:[ID] avar
398:[DOT] .
398:[ID] value
398:[LPAREN] (
398:[RPAREN] )
398:[RPAREN] )
398:[SEMICOLON] ;
399:[LPAREN] (
399:[LET] let
399:[ID] r
399:[COLON] :
399:[TYPE] Int
399:[ASSIGN] <-
399:[LPAREN] (
399:[ID] avar
399:[DOT] .
399:[ID] value
399:[LPAREN] (
399:[RPAREN] )
399:[MINUS] -
399:[LPAREN] (
399:[ID] x
399:[DOT] .
399:[ID] value
399:[LPAREN] (
399:[RPAREN] )
399:[MUL] *
399:[INTEGER] 8
399:[RPAREN] )
399:[RPAREN] )
399:[IN] in
400:[LBRACE] {
401:[ID] out_string
401:[LPAREN] (
401:[STRING] "number "
401:[RPAREN] )
401:[SEMICOLON] ;
402:[ID] print
402:[LPAREN] (
402:[ID] avar
402:[RPAREN] )
402:[SEMICOLON] ;
403:[ID] out_string
403:[LPAREN] (
403:[STRING] "is equal to "
403:[RPAREN] )
403:[SEMICOLON] ;
404:[ID] print
404:[LPAREN] (
404:[ID] x
404:[RPAREN] )
404:[SEMICOLON] ;
405:[ID] out_string
405:[LPAREN] (
405:[STRING] "times 8 with a remainder of "
405:[RPAREN] )
405:[SEMICOLON] ;
406:[LPAREN] (
406:[LET] let
406:[ID] a
406:[COLON] :
406:[TYPE] A2I
406:[ASSIGN] <-
406:[NEW] new
406:[TYPE] A2I
406:[IN] in
407:[LBRACE] {
408:[ID] out_string
408:[LPAREN] (
408:[ID] a
408:[DOT] .
408:[ID] i2a
408:[LPAREN] (
408:[ID] r
408:[RPAREN] )
408:[RPAREN] )
408:[SEMICOLON] ;
409:[ID] out_string
409:[LPAREN] (
409:[STRING] "\n"
409:[RPAREN] )
409:[SEMICOLON] ;
410:[RBRACE] }
411:[RPAREN] )
411:[SEMICOLON] ;
412:[RBRACE] }
413:[RPAREN] )
413:[SEMICOLON] ;
414:[ID] avar
414:[ASSIGN] <-
414:[ID] x
414:[SEMICOLON] ;
415:[RBRACE] }
416:[RPAREN] )
417:[ELSE] else
418:[IF] if
418:[ID] char
418:[EQUAL] =
418:[STRING] "j"
418:[THEN] then
418:[ID] avar
418:[ASSIGN] <-
418:[LPAREN] (
418:[NEW] new
418:[TYPE] A
418:[RPAREN] )
419:[ELSE] else
420:[IF] if
420:[ID] char
420:[EQUAL] =
420:[STRING] "q"
420:[THEN] then
420:[ID] flag
420:[ASSIGN] <-
420:[FALSE] false
421:[ELSE] else
422:[ID] avar
422:[ASSIGN] <-
422:[LPAREN] (
422:[NEW] new
422:[TYPE] A
422:[RPAREN] )
422:[DOT] .
422:[ID] method1
422:[LPAREN] (
422:[ID] avar
422:[DOT] .
422:[ID] value
422:[LPAREN] (
422:[RPAREN] )
422:[RPAREN] )
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[FI] fi
423:[SEMICOLON] ;
424:[RBRACE] }
425:[POOL] pool
425:[SEMICOLON] ;
426:[RBRACE] }
427:[RBRACE] }
427:[SEMICOLON] ;
429:[RBRACE] }
429:[SEMICOLON] ;
