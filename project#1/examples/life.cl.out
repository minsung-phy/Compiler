045:[CLASS] class
045:[TYPE] Board
045:[INHERITS] inherits
045:[TYPE] IO
045:[LBRACE] {
047:[ID] rows
047:[COLON] :
047:[TYPE] Int
047:[SEMICOLON] ;
048:[ID] columns
048:[COLON] :
048:[TYPE] Int
048:[SEMICOLON] ;
049:[ID] board_size
049:[COLON] :
049:[TYPE] Int
049:[SEMICOLON] ;
051:[ID] size_of_board
051:[LPAREN] (
051:[ID] initial
051:[COLON] :
051:[TYPE] String
051:[RPAREN] )
051:[COLON] :
051:[TYPE] Int
051:[LBRACE] {
052:[ID] initial
052:[DOT] .
052:[ID] length
052:[LPAREN] (
052:[RPAREN] )
053:[RBRACE] }
053:[SEMICOLON] ;
055:[ID] board_init
055:[LPAREN] (
055:[ID] start
055:[COLON] :
055:[TYPE] String
055:[RPAREN] )
055:[COLON] :
055:[TYPE] SELF_TYPE
055:[LBRACE] {
056:[LPAREN] (
056:[LET] let
056:[ID] size
056:[COLON] :
056:[TYPE] Int
056:[ASSIGN] <-
056:[ID] size_of_board
056:[LPAREN] (
056:[ID] start
056:[RPAREN] )
056:[IN] in
057:[LBRACE] {
058:[IF] if
058:[ID] size
058:[EQUAL] =
058:[INTEGER] 15
058:[THEN] then
059:[LBRACE] {
060:[ID] rows
060:[ASSIGN] <-
060:[INTEGER] 3
060:[SEMICOLON] ;
061:[ID] columns
061:[ASSIGN] <-
061:[INTEGER] 5
061:[SEMICOLON] ;
062:[ID] board_size
062:[ASSIGN] <-
062:[ID] size
062:[SEMICOLON] ;
063:[RBRACE] }
064:[ELSE] else
064:[IF] if
064:[ID] size
064:[EQUAL] =
064:[INTEGER] 16
064:[THEN] then
065:[LBRACE] {
066:[ID] rows
066:[ASSIGN] <-
066:[INTEGER] 4
066:[SEMICOLON] ;
067:[ID] columns
067:[ASSIGN] <-
067:[INTEGER] 4
067:[SEMICOLON] ;
068:[ID] board_size
068:[ASSIGN] <-
068:[ID] size
068:[SEMICOLON] ;
069:[RBRACE] }
070:[ELSE] else
070:[IF] if
070:[ID] size
070:[EQUAL] =
070:[INTEGER] 20
070:[THEN] then
071:[LBRACE] {
072:[ID] rows
072:[ASSIGN] <-
072:[INTEGER] 4
072:[SEMICOLON] ;
073:[ID] columns
073:[ASSIGN] <-
073:[INTEGER] 5
073:[SEMICOLON] ;
074:[ID] board_size
074:[ASSIGN] <-
074:[ID] size
074:[SEMICOLON] ;
075:[RBRACE] }
076:[ELSE] else
076:[IF] if
076:[ID] size
076:[EQUAL] =
076:[INTEGER] 21
076:[THEN] then
077:[LBRACE] {
078:[ID] rows
078:[ASSIGN] <-
078:[INTEGER] 3
078:[SEMICOLON] ;
079:[ID] columns
079:[ASSIGN] <-
079:[INTEGER] 7
079:[SEMICOLON] ;
080:[ID] board_size
080:[ASSIGN] <-
080:[ID] size
080:[SEMICOLON] ;
081:[RBRACE] }
082:[ELSE] else
082:[IF] if
082:[ID] size
082:[EQUAL] =
082:[INTEGER] 25
082:[THEN] then
083:[LBRACE] {
084:[ID] rows
084:[ASSIGN] <-
084:[INTEGER] 5
084:[SEMICOLON] ;
085:[ID] columns
085:[ASSIGN] <-
085:[INTEGER] 5
085:[SEMICOLON] ;
086:[ID] board_size
086:[ASSIGN] <-
086:[ID] size
086:[SEMICOLON] ;
087:[RBRACE] }
088:[ELSE] else
088:[IF] if
088:[ID] size
088:[EQUAL] =
088:[INTEGER] 28
088:[THEN] then
089:[LBRACE] {
090:[ID] rows
090:[ASSIGN] <-
090:[INTEGER] 7
090:[SEMICOLON] ;
091:[ID] columns
091:[ASSIGN] <-
091:[INTEGER] 4
091:[SEMICOLON] ;
092:[ID] board_size
092:[ASSIGN] <-
092:[ID] size
092:[SEMICOLON] ;
093:[RBRACE] }
094:[ELSE] else
095:[LBRACE] {
096:[ID] rows
096:[ASSIGN] <-
096:[INTEGER] 5
096:[SEMICOLON] ;
097:[ID] columns
097:[ASSIGN] <-
097:[INTEGER] 5
097:[SEMICOLON] ;
098:[ID] board_size
098:[ASSIGN] <-
098:[ID] size
098:[SEMICOLON] ;
099:[RBRACE] }
100:[FI] fi
100:[FI] fi
100:[FI] fi
100:[FI] fi
100:[FI] fi
100:[FI] fi
100:[SEMICOLON] ;
101:[ID] self
101:[SEMICOLON] ;
102:[RBRACE] }
103:[RPAREN] )
104:[RBRACE] }
104:[SEMICOLON] ;
106:[RBRACE] }
106:[SEMICOLON] ;
110:[CLASS] class
110:[TYPE] CellularAutomaton
110:[INHERITS] inherits
110:[TYPE] Board
110:[LBRACE] {
111:[ID] population_map
111:[COLON] :
111:[TYPE] String
111:[SEMICOLON] ;
113:[ID] init
113:[LPAREN] (
113:[ID] map
113:[COLON] :
113:[TYPE] String
113:[RPAREN] )
113:[COLON] :
113:[TYPE] SELF_TYPE
113:[LBRACE] {
114:[LBRACE] {
115:[ID] population_map
115:[ASSIGN] <-
115:[ID] map
115:[SEMICOLON] ;
116:[ID] board_init
116:[LPAREN] (
116:[ID] map
116:[RPAREN] )
116:[SEMICOLON] ;
117:[ID] self
117:[SEMICOLON] ;
118:[RBRACE] }
119:[RBRACE] }
119:[SEMICOLON] ;
124:[ID] print
124:[LPAREN] (
124:[RPAREN] )
124:[COLON] :
124:[TYPE] SELF_TYPE
124:[LBRACE] {
126:[LPAREN] (
126:[LET] let
126:[ID] i
126:[COLON] :
126:[TYPE] Int
126:[ASSIGN] <-
126:[INTEGER] 0
126:[IN] in
127:[LPAREN] (
127:[LET] let
127:[ID] num
127:[COLON] :
127:[TYPE] Int
127:[ASSIGN] <-
127:[ID] board_size
127:[IN] in
128:[LBRACE] {
129:[ID] out_string
129:[LPAREN] (
129:[STRING] "\n"
129:[RPAREN] )
129:[SEMICOLON] ;
130:[WHILE] while
130:[ID] i
130:[LT] <
130:[ID] num
130:[LOOP] loop
131:[LBRACE] {
132:[ID] out_string
132:[LPAREN] (
132:[ID] population_map
132:[DOT] .
132:[ID] substr
132:[LPAREN] (
132:[ID] i
132:[COMMA] ,
132:[ID] columns
132:[RPAREN] )
132:[RPAREN] )
132:[SEMICOLON] ;
133:[ID] out_string
133:[LPAREN] (
133:[STRING] "\n"
133:[RPAREN] )
133:[SEMICOLON] ;
134:[ID] i
134:[ASSIGN] <-
134:[ID] i
134:[PLUS] +
134:[ID] columns
134:[SEMICOLON] ;
135:[RBRACE] }
136:[POOL] pool
136:[SEMICOLON] ;
137:[ID] out_string
137:[LPAREN] (
137:[STRING] "\n"
137:[RPAREN] )
137:[SEMICOLON] ;
138:[ID] self
138:[SEMICOLON] ;
139:[RBRACE] }
140:[RPAREN] )
140:[RPAREN] )
141:[RBRACE] }
141:[SEMICOLON] ;
143:[ID] num_cells
143:[LPAREN] (
143:[RPAREN] )
143:[COLON] :
143:[TYPE] Int
143:[LBRACE] {
144:[ID] population_map
144:[DOT] .
144:[ID] length
144:[LPAREN] (
144:[RPAREN] )
145:[RBRACE] }
145:[SEMICOLON] ;
147:[ID] cell
147:[LPAREN] (
147:[ID] position
147:[COLON] :
147:[TYPE] Int
147:[RPAREN] )
147:[COLON] :
147:[TYPE] String
147:[LBRACE] {
148:[IF] if
148:[ID] board_size
148:[MINUS] -
148:[INTEGER] 1
148:[LT] <
148:[ID] position
148:[THEN] then
149:[STRING] " "
150:[ELSE] else
151:[ID] population_map
151:[DOT] .
151:[ID] substr
151:[LPAREN] (
151:[ID] position
151:[COMMA] ,
151:[INTEGER] 1
151:[RPAREN] )
152:[FI] fi
153:[RBRACE] }
153:[SEMICOLON] ;
155:[ID] north
155:[LPAREN] (
155:[ID] position
155:[COLON] :
155:[TYPE] Int
155:[RPAREN] )
155:[COLON] :
155:[TYPE] String
155:[LBRACE] {
156:[IF] if
156:[LPAREN] (
156:[ID] position
156:[MINUS] -
156:[ID] columns
156:[RPAREN] )
156:[LT] <
156:[INTEGER] 0
156:[THEN] then
157:[STRING] " "
158:[ELSE] else
159:[ID] cell
159:[LPAREN] (
159:[ID] position
159:[MINUS] -
159:[ID] columns
159:[RPAREN] )
160:[FI] fi
161:[RBRACE] }
161:[SEMICOLON] ;
163:[ID] south
163:[LPAREN] (
163:[ID] position
163:[COLON] :
163:[TYPE] Int
163:[RPAREN] )
163:[COLON] :
163:[TYPE] String
163:[LBRACE] {
164:[IF] if
164:[ID] board_size
164:[LT] <
164:[LPAREN] (
164:[ID] position
164:[PLUS] +
164:[ID] columns
164:[RPAREN] )
164:[THEN] then
165:[STRING] " "
166:[ELSE] else
167:[ID] cell
167:[LPAREN] (
167:[ID] position
167:[PLUS] +
167:[ID] columns
167:[RPAREN] )
168:[FI] fi
169:[RBRACE] }
169:[SEMICOLON] ;
171:[ID] east
171:[LPAREN] (
171:[ID] position
171:[COLON] :
171:[TYPE] Int
171:[RPAREN] )
171:[COLON] :
171:[TYPE] String
171:[LBRACE] {
172:[IF] if
172:[LPAREN] (
172:[LPAREN] (
172:[LPAREN] (
172:[ID] position
172:[PLUS] +
172:[INTEGER] 1
172:[RPAREN] )
172:[DIV] /
172:[ID] columns
172:[RPAREN] )
172:[MUL] *
172:[ID] columns
172:[RPAREN] )
172:[EQUAL] =
172:[LPAREN] (
172:[ID] position
172:[PLUS] +
172:[INTEGER] 1
172:[RPAREN] )
172:[THEN] then
173:[STRING] " "
174:[ELSE] else
175:[ID] cell
175:[LPAREN] (
175:[ID] position
175:[PLUS] +
175:[INTEGER] 1
175:[RPAREN] )
176:[FI] fi
177:[RBRACE] }
177:[SEMICOLON] ;
179:[ID] west
179:[LPAREN] (
179:[ID] position
179:[COLON] :
179:[TYPE] Int
179:[RPAREN] )
179:[COLON] :
179:[TYPE] String
179:[LBRACE] {
180:[IF] if
180:[ID] position
180:[EQUAL] =
180:[INTEGER] 0
180:[THEN] then
181:[STRING] " "
182:[ELSE] else
183:[IF] if
183:[LPAREN] (
183:[LPAREN] (
183:[ID] position
183:[DIV] /
183:[ID] columns
183:[RPAREN] )
183:[MUL] *
183:[ID] columns
183:[RPAREN] )
183:[EQUAL] =
183:[ID] position
183:[THEN] then
184:[STRING] " "
185:[ELSE] else
186:[ID] cell
186:[LPAREN] (
186:[ID] position
186:[MINUS] -
186:[INTEGER] 1
186:[RPAREN] )
187:[FI] fi
187:[FI] fi
188:[RBRACE] }
188:[SEMICOLON] ;
190:[ID] northwest
190:[LPAREN] (
190:[ID] position
190:[COLON] :
190:[TYPE] Int
190:[RPAREN] )
190:[COLON] :
190:[TYPE] String
190:[LBRACE] {
191:[IF] if
191:[LPAREN] (
191:[ID] position
191:[MINUS] -
191:[ID] columns
191:[RPAREN] )
191:[LT] <
191:[INTEGER] 0
191:[THEN] then
192:[STRING] " "
193:[ELSE] else
193:[IF] if
193:[LPAREN] (
193:[LPAREN] (
193:[ID] position
193:[DIV] /
193:[ID] columns
193:[RPAREN] )
193:[MUL] *
193:[ID] columns
193:[RPAREN] )
193:[EQUAL] =
193:[ID] position
193:[THEN] then
194:[STRING] " "
195:[ELSE] else
196:[ID] north
196:[LPAREN] (
196:[ID] position
196:[MINUS] -
196:[INTEGER] 1
196:[RPAREN] )
197:[FI] fi
197:[FI] fi
198:[RBRACE] }
198:[SEMICOLON] ;
200:[ID] northeast
200:[LPAREN] (
200:[ID] position
200:[COLON] :
200:[TYPE] Int
200:[RPAREN] )
200:[COLON] :
200:[TYPE] String
200:[LBRACE] {
201:[IF] if
201:[LPAREN] (
201:[ID] position
201:[MINUS] -
201:[ID] columns
201:[RPAREN] )
201:[LT] <
201:[INTEGER] 0
201:[THEN] then
202:[STRING] " "
203:[ELSE] else
203:[IF] if
203:[LPAREN] (
203:[LPAREN] (
203:[LPAREN] (
203:[ID] position
203:[PLUS] +
203:[INTEGER] 1
203:[RPAREN] )
203:[DIV] /
203:[ID] columns
203:[RPAREN] )
203:[MUL] *
203:[ID] columns
203:[RPAREN] )
203:[EQUAL] =
203:[LPAREN] (
203:[ID] position
203:[PLUS] +
203:[INTEGER] 1
203:[RPAREN] )
203:[THEN] then
204:[STRING] " "
205:[ELSE] else
206:[ID] north
206:[LPAREN] (
206:[ID] position
206:[PLUS] +
206:[INTEGER] 1
206:[RPAREN] )
207:[FI] fi
207:[FI] fi
208:[RBRACE] }
208:[SEMICOLON] ;
210:[ID] southeast
210:[LPAREN] (
210:[ID] position
210:[COLON] :
210:[TYPE] Int
210:[RPAREN] )
210:[COLON] :
210:[TYPE] String
210:[LBRACE] {
211:[IF] if
211:[ID] board_size
211:[LT] <
211:[LPAREN] (
211:[ID] position
211:[PLUS] +
211:[ID] columns
211:[RPAREN] )
211:[THEN] then
212:[STRING] " "
213:[ELSE] else
213:[IF] if
213:[LPAREN] (
213:[LPAREN] (
213:[LPAREN] (
213:[ID] position
213:[PLUS] +
213:[INTEGER] 1
213:[RPAREN] )
213:[DIV] /
213:[ID] columns
213:[RPAREN] )
213:[MUL] *
213:[ID] columns
213:[RPAREN] )
213:[EQUAL] =
213:[LPAREN] (
213:[ID] position
213:[PLUS] +
213:[INTEGER] 1
213:[RPAREN] )
213:[THEN] then
214:[STRING] " "
215:[ELSE] else
216:[ID] south
216:[LPAREN] (
216:[ID] position
216:[PLUS] +
216:[INTEGER] 1
216:[RPAREN] )
217:[FI] fi
217:[FI] fi
218:[RBRACE] }
218:[SEMICOLON] ;
220:[ID] southwest
220:[LPAREN] (
220:[ID] position
220:[COLON] :
220:[TYPE] Int
220:[RPAREN] )
220:[COLON] :
220:[TYPE] String
220:[LBRACE] {
221:[IF] if
221:[ID] board_size
221:[LT] <
221:[LPAREN] (
221:[ID] position
221:[PLUS] +
221:[ID] columns
221:[RPAREN] )
221:[THEN] then
222:[STRING] " "
223:[ELSE] else
223:[IF] if
223:[LPAREN] (
223:[LPAREN] (
223:[ID] position
223:[DIV] /
223:[ID] columns
223:[RPAREN] )
223:[MUL] *
223:[ID] columns
223:[RPAREN] )
223:[EQUAL] =
223:[ID] position
223:[THEN] then
224:[STRING] " "
225:[ELSE] else
226:[ID] south
226:[LPAREN] (
226:[ID] position
226:[MINUS] -
226:[INTEGER] 1
226:[RPAREN] )
227:[FI] fi
227:[FI] fi
228:[RBRACE] }
228:[SEMICOLON] ;
230:[ID] neighbors
230:[LPAREN] (
230:[ID] position
230:[COLON] :
230:[TYPE] Int
230:[RPAREN] )
230:[COLON] :
230:[TYPE] Int
230:[LBRACE] {
231:[LBRACE] {
232:[IF] if
232:[ID] north
232:[LPAREN] (
232:[ID] position
232:[RPAREN] )
232:[EQUAL] =
232:[STRING] "X"
232:[THEN] then
232:[INTEGER] 1
232:[ELSE] else
232:[INTEGER] 0
232:[FI] fi
233:[PLUS] +
233:[IF] if
233:[ID] south
233:[LPAREN] (
233:[ID] position
233:[RPAREN] )
233:[EQUAL] =
233:[STRING] "X"
233:[THEN] then
233:[INTEGER] 1
233:[ELSE] else
233:[INTEGER] 0
233:[FI] fi
234:[PLUS] +
234:[IF] if
234:[ID] east
234:[LPAREN] (
234:[ID] position
234:[RPAREN] )
234:[EQUAL] =
234:[STRING] "X"
234:[THEN] then
234:[INTEGER] 1
234:[ELSE] else
234:[INTEGER] 0
234:[FI] fi
235:[PLUS] +
235:[IF] if
235:[ID] west
235:[LPAREN] (
235:[ID] position
235:[RPAREN] )
235:[EQUAL] =
235:[STRING] "X"
235:[THEN] then
235:[INTEGER] 1
235:[ELSE] else
235:[INTEGER] 0
235:[FI] fi
236:[PLUS] +
236:[IF] if
236:[ID] northeast
236:[LPAREN] (
236:[ID] position
236:[RPAREN] )
236:[EQUAL] =
236:[STRING] "X"
236:[THEN] then
236:[INTEGER] 1
236:[ELSE] else
236:[INTEGER] 0
236:[FI] fi
237:[PLUS] +
237:[IF] if
237:[ID] northwest
237:[LPAREN] (
237:[ID] position
237:[RPAREN] )
237:[EQUAL] =
237:[STRING] "X"
237:[THEN] then
237:[INTEGER] 1
237:[ELSE] else
237:[INTEGER] 0
237:[FI] fi
238:[PLUS] +
238:[IF] if
238:[ID] southeast
238:[LPAREN] (
238:[ID] position
238:[RPAREN] )
238:[EQUAL] =
238:[STRING] "X"
238:[THEN] then
238:[INTEGER] 1
238:[ELSE] else
238:[INTEGER] 0
238:[FI] fi
239:[PLUS] +
239:[IF] if
239:[ID] southwest
239:[LPAREN] (
239:[ID] position
239:[RPAREN] )
239:[EQUAL] =
239:[STRING] "X"
239:[THEN] then
239:[INTEGER] 1
239:[ELSE] else
239:[INTEGER] 0
239:[FI] fi
239:[SEMICOLON] ;
240:[RBRACE] }
241:[RBRACE] }
241:[SEMICOLON] ;
247:[ID] cell_at_next_evolution
247:[LPAREN] (
247:[ID] position
247:[COLON] :
247:[TYPE] Int
247:[RPAREN] )
247:[COLON] :
247:[TYPE] String
247:[LBRACE] {
249:[IF] if
249:[ID] neighbors
249:[LPAREN] (
249:[ID] position
249:[RPAREN] )
249:[EQUAL] =
249:[INTEGER] 3
249:[THEN] then
250:[STRING] "X"
251:[ELSE] else
252:[IF] if
252:[ID] neighbors
252:[LPAREN] (
252:[ID] position
252:[RPAREN] )
252:[EQUAL] =
252:[INTEGER] 2
252:[THEN] then
253:[IF] if
253:[ID] cell
253:[LPAREN] (
253:[ID] position
253:[RPAREN] )
253:[EQUAL] =
253:[STRING] "X"
253:[THEN] then
254:[STRING] "X"
255:[ELSE] else
256:[STRING] "-"
257:[FI] fi
258:[ELSE] else
259:[STRING] "-"
260:[FI] fi
260:[FI] fi
261:[RBRACE] }
261:[SEMICOLON] ;
264:[ID] evolve
264:[LPAREN] (
264:[RPAREN] )
264:[COLON] :
264:[TYPE] SELF_TYPE
264:[LBRACE] {
265:[LPAREN] (
265:[LET] let
265:[ID] position
265:[COLON] :
265:[TYPE] Int
265:[ASSIGN] <-
265:[INTEGER] 0
265:[IN] in
266:[LPAREN] (
266:[LET] let
266:[ID] num
266:[COLON] :
266:[TYPE] Int
266:[ASSIGN] <-
266:[ID] num_cells
266:[LPAREN] (
266:[RPAREN] )
266:[IN] in
267:[LPAREN] (
267:[LET] let
267:[ID] temp
267:[COLON] :
267:[TYPE] String
267:[IN] in
268:[LBRACE] {
269:[WHILE] while
269:[ID] position
269:[LT] <
269:[ID] num
269:[LOOP] loop
270:[LBRACE] {
271:[ID] temp
271:[ASSIGN] <-
271:[ID] temp
271:[DOT] .
271:[ID] concat
271:[LPAREN] (
271:[ID] cell_at_next_evolution
271:[LPAREN] (
271:[ID] position
271:[RPAREN] )
271:[RPAREN] )
271:[SEMICOLON] ;
272:[ID] position
272:[ASSIGN] <-
272:[ID] position
272:[PLUS] +
272:[INTEGER] 1
272:[SEMICOLON] ;
273:[RBRACE] }
274:[POOL] pool
274:[SEMICOLON] ;
275:[ID] population_map
275:[ASSIGN] <-
275:[ID] temp
275:[SEMICOLON] ;
276:[ID] self
276:[SEMICOLON] ;
277:[RBRACE] }
278:[RPAREN] )
278:[RPAREN] )
278:[RPAREN] )
279:[RBRACE] }
279:[SEMICOLON] ;
284:[ID] option
284:[LPAREN] (
284:[RPAREN] )
284:[COLON] :
284:[TYPE] String
284:[LBRACE] {
285:[LBRACE] {
286:[LPAREN] (
286:[LET] let
286:[ID] num
286:[COLON] :
286:[TYPE] Int
286:[IN] in
287:[LBRACE] {
288:[ID] out_string
288:[LPAREN] (
288:[STRING] "\nPlease chose a number:\n"
288:[RPAREN] )
288:[SEMICOLON] ;
289:[ID] out_string
289:[LPAREN] (
289:[STRING] "\t1: A cross\n"
289:[RPAREN] )
289:[SEMICOLON] ;
290:[ID] out_string
290:[LPAREN] (
290:[STRING] "\t2: A slash from the upper left to lower right\n"
290:[RPAREN] )
290:[SEMICOLON] ;
291:[ID] out_string
291:[LPAREN] (
291:[STRING] "\t3: A slash from the upper right to lower left\n"
291:[RPAREN] )
291:[SEMICOLON] ;
292:[ID] out_string
292:[LPAREN] (
292:[STRING] "\t4: An X\n"
292:[RPAREN] )
292:[SEMICOLON] ;
293:[ID] out_string
293:[LPAREN] (
293:[STRING] "\t5: A greater than sign \n"
293:[RPAREN] )
293:[SEMICOLON] ;
294:[ID] out_string
294:[LPAREN] (
294:[STRING] "\t6: A less than sign\n"
294:[RPAREN] )
294:[SEMICOLON] ;
295:[ID] out_string
295:[LPAREN] (
295:[STRING] "\t7: Two greater than signs\n"
295:[RPAREN] )
295:[SEMICOLON] ;
296:[ID] out_string
296:[LPAREN] (
296:[STRING] "\t8: Two less than signs\n"
296:[RPAREN] )
296:[SEMICOLON] ;
297:[ID] out_string
297:[LPAREN] (
297:[STRING] "\t9: A 'V'\n"
297:[RPAREN] )
297:[SEMICOLON] ;
298:[ID] out_string
298:[LPAREN] (
298:[STRING] "\t10: An inverse 'V'\n"
298:[RPAREN] )
298:[SEMICOLON] ;
299:[ID] out_string
299:[LPAREN] (
299:[STRING] "\t11: Numbers 9 and 10 combined\n"
299:[RPAREN] )
299:[SEMICOLON] ;
300:[ID] out_string
300:[LPAREN] (
300:[STRING] "\t12: A full grid\n"
300:[RPAREN] )
300:[SEMICOLON] ;
301:[ID] out_string
301:[LPAREN] (
301:[STRING] "\t13: A 'T'\n"
301:[RPAREN] )
301:[SEMICOLON] ;
302:[ID] out_string
302:[LPAREN] (
302:[STRING] "\t14: A plus '+'\n"
302:[RPAREN] )
302:[SEMICOLON] ;
303:[ID] out_string
303:[LPAREN] (
303:[STRING] "\t15: A 'W'\n"
303:[RPAREN] )
303:[SEMICOLON] ;
304:[ID] out_string
304:[LPAREN] (
304:[STRING] "\t16: An 'M'\n"
304:[RPAREN] )
304:[SEMICOLON] ;
305:[ID] out_string
305:[LPAREN] (
305:[STRING] "\t17: An 'E'\n"
305:[RPAREN] )
305:[SEMICOLON] ;
306:[ID] out_string
306:[LPAREN] (
306:[STRING] "\t18: A '3'\n"
306:[RPAREN] )
306:[SEMICOLON] ;
307:[ID] out_string
307:[LPAREN] (
307:[STRING] "\t19: An 'O'\n"
307:[RPAREN] )
307:[SEMICOLON] ;
308:[ID] out_string
308:[LPAREN] (
308:[STRING] "\t20: An '8'\n"
308:[RPAREN] )
308:[SEMICOLON] ;
309:[ID] out_string
309:[LPAREN] (
309:[STRING] "\t21: An 'S'\n"
309:[RPAREN] )
309:[SEMICOLON] ;
310:[ID] out_string
310:[LPAREN] (
310:[STRING] "Your choice => "
310:[RPAREN] )
310:[SEMICOLON] ;
311:[ID] num
311:[ASSIGN] <-
311:[ID] in_int
311:[LPAREN] (
311:[RPAREN] )
311:[SEMICOLON] ;
312:[ID] out_string
312:[LPAREN] (
312:[STRING] "\n"
312:[RPAREN] )
312:[SEMICOLON] ;
313:[IF] if
313:[ID] num
313:[EQUAL] =
313:[INTEGER] 1
313:[THEN] then
314:[STRING] " XX  XXXX XXXX  XX  "
315:[ELSE] else
315:[IF] if
315:[ID] num
315:[EQUAL] =
315:[INTEGER] 2
315:[THEN] then
316:[STRING] "    X   X   X   X   X    "
317:[ELSE] else
317:[IF] if
317:[ID] num
317:[EQUAL] =
317:[INTEGER] 3
317:[THEN] then
318:[STRING] "X     X     X     X     X"
319:[ELSE] else
319:[IF] if
319:[ID] num
319:[EQUAL] =
319:[INTEGER] 4
319:[THEN] then
320:[STRING] "X   X X X   X   X X X   X"
321:[ELSE] else
321:[IF] if
321:[ID] num
321:[EQUAL] =
321:[INTEGER] 5
321:[THEN] then
322:[STRING] "X     X     X   X   X    "
323:[ELSE] else
323:[IF] if
323:[ID] num
323:[EQUAL] =
323:[INTEGER] 6
323:[THEN] then
324:[STRING] "    X   X   X     X     X"
325:[ELSE] else
325:[IF] if
325:[ID] num
325:[EQUAL] =
325:[INTEGER] 7
325:[THEN] then
326:[STRING] "X  X  X  XX  X      "
327:[ELSE] else
327:[IF] if
327:[ID] num
327:[EQUAL] =
327:[INTEGER] 8
327:[THEN] then
328:[STRING] " X  XX  X  X  X     "
329:[ELSE] else
329:[IF] if
329:[ID] num
329:[EQUAL] =
329:[INTEGER] 9
329:[THEN] then
330:[STRING] "X   X X X   X  "
331:[ELSE] else
331:[IF] if
331:[ID] num
331:[EQUAL] =
331:[INTEGER] 10
331:[THEN] then
332:[STRING] "  X   X X X   X"
333:[ELSE] else
333:[IF] if
333:[ID] num
333:[EQUAL] =
333:[INTEGER] 11
333:[THEN] then
334:[STRING] "X X X X X X X X"
335:[ELSE] else
335:[IF] if
335:[ID] num
335:[EQUAL] =
335:[INTEGER] 12
335:[THEN] then
336:[STRING] "XXXXXXXXXXXXXXXXXXXXXXXXX"
337:[ELSE] else
337:[IF] if
337:[ID] num
337:[EQUAL] =
337:[INTEGER] 13
337:[THEN] then
338:[STRING] "XXXXX  X    X    X    X  "
339:[ELSE] else
339:[IF] if
339:[ID] num
339:[EQUAL] =
339:[INTEGER] 14
339:[THEN] then
340:[STRING] "  X    X  XXXXX  X    X  "
341:[ELSE] else
341:[IF] if
341:[ID] num
341:[EQUAL] =
341:[INTEGER] 15
341:[THEN] then
342:[STRING] "X     X X X X   X X  "
343:[ELSE] else
343:[IF] if
343:[ID] num
343:[EQUAL] =
343:[INTEGER] 16
343:[THEN] then
344:[STRING] "  X X   X X X X     X"
345:[ELSE] else
345:[IF] if
345:[ID] num
345:[EQUAL] =
345:[INTEGER] 17
345:[THEN] then
346:[STRING] "XXXXX   X   XXXXX   X   XXXX"
347:[ELSE] else
347:[IF] if
347:[ID] num
347:[EQUAL] =
347:[INTEGER] 18
347:[THEN] then
348:[STRING] "XXX    X   X  X    X   XXXX "
349:[ELSE] else
349:[IF] if
349:[ID] num
349:[EQUAL] =
349:[INTEGER] 19
349:[THEN] then
350:[STRING] " XX X  XX  X XX "
351:[ELSE] else
351:[IF] if
351:[ID] num
351:[EQUAL] =
351:[INTEGER] 20
351:[THEN] then
352:[STRING] " XX X  XX  X XX X  XX  X XX "
353:[ELSE] else
353:[IF] if
353:[ID] num
353:[EQUAL] =
353:[INTEGER] 21
353:[THEN] then
354:[STRING] " XXXX   X    XX    X   XXXX "
355:[ELSE] else
356:[STRING] "                         "
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[FI] fi
357:[SEMICOLON] ;
358:[RBRACE] }
359:[RPAREN] )
359:[SEMICOLON] ;
360:[RBRACE] }
361:[RBRACE] }
361:[SEMICOLON] ;
366:[ID] prompt
366:[LPAREN] (
366:[RPAREN] )
366:[COLON] :
366:[TYPE] Bool
366:[LBRACE] {
367:[LBRACE] {
368:[LPAREN] (
368:[LET] let
368:[ID] ans
368:[COLON] :
368:[TYPE] String
368:[IN] in
369:[LBRACE] {
370:[ID] out_string
370:[LPAREN] (
370:[STRING] "Would you like to continue with the next generation? \n"
370:[RPAREN] )
370:[SEMICOLON] ;
371:[ID] out_string
371:[LPAREN] (
371:[STRING] "Please use lowercase y or n for your answer [y]: "
371:[RPAREN] )
371:[SEMICOLON] ;
372:[ID] ans
372:[ASSIGN] <-
372:[ID] in_string
372:[LPAREN] (
372:[RPAREN] )
372:[SEMICOLON] ;
373:[ID] out_string
373:[LPAREN] (
373:[STRING] "\n"
373:[RPAREN] )
373:[SEMICOLON] ;
374:[IF] if
374:[ID] ans
374:[EQUAL] =
374:[STRING] "n"
374:[THEN] then
375:[FALSE] false
376:[ELSE] else
377:[TRUE] true
378:[FI] fi
378:[SEMICOLON] ;
379:[RBRACE] }
380:[RPAREN] )
380:[SEMICOLON] ;
381:[RBRACE] }
382:[RBRACE] }
382:[SEMICOLON] ;
385:[ID] prompt2
385:[LPAREN] (
385:[RPAREN] )
385:[COLON] :
385:[TYPE] Bool
385:[LBRACE] {
386:[LPAREN] (
386:[LET] let
386:[ID] ans
386:[COLON] :
386:[TYPE] String
386:[IN] in
387:[LBRACE] {
388:[ID] out_string
388:[LPAREN] (
388:[STRING] "\n\n"
388:[RPAREN] )
388:[SEMICOLON] ;
389:[ID] out_string
389:[LPAREN] (
389:[STRING] "Would you like to choose a background pattern? \n"
389:[RPAREN] )
389:[SEMICOLON] ;
390:[ID] out_string
390:[LPAREN] (
390:[STRING] "Please use lowercase y or n for your answer [n]: "
390:[RPAREN] )
390:[SEMICOLON] ;
391:[ID] ans
391:[ASSIGN] <-
391:[ID] in_string
391:[LPAREN] (
391:[RPAREN] )
391:[SEMICOLON] ;
392:[IF] if
392:[ID] ans
392:[EQUAL] =
392:[STRING] "y"
392:[THEN] then
393:[TRUE] true
394:[ELSE] else
395:[FALSE] false
396:[FI] fi
396:[SEMICOLON] ;
397:[RBRACE] }
398:[RPAREN] )
399:[RBRACE] }
399:[SEMICOLON] ;
402:[RBRACE] }
402:[SEMICOLON] ;
404:[CLASS] class
404:[TYPE] Main
404:[INHERITS] inherits
404:[TYPE] CellularAutomaton
404:[LBRACE] {
405:[ID] cells
405:[COLON] :
405:[TYPE] CellularAutomaton
405:[SEMICOLON] ;
407:[ID] main
407:[LPAREN] (
407:[RPAREN] )
407:[COLON] :
407:[TYPE] SELF_TYPE
407:[LBRACE] {
408:[LBRACE] {
409:[LPAREN] (
409:[LET] let
409:[ID] continue
409:[COLON] :
409:[TYPE] Bool
409:[IN] in
410:[LPAREN] (
410:[LET] let
410:[ID] choice
410:[COLON] :
410:[TYPE] String
410:[IN] in
411:[LBRACE] {
412:[ID] out_string
412:[LPAREN] (
412:[STRING] "Welcome to the Game of Life.\n"
412:[RPAREN] )
412:[SEMICOLON] ;
413:[ID] out_string
413:[LPAREN] (
413:[STRING] "There are many initial states to choose from. \n"
413:[RPAREN] )
413:[SEMICOLON] ;
414:[WHILE] while
414:[ID] prompt2
414:[LPAREN] (
414:[RPAREN] )
414:[LOOP] loop
415:[LBRACE] {
416:[ID] continue
416:[ASSIGN] <-
416:[TRUE] true
416:[SEMICOLON] ;
417:[ID] choice
417:[ASSIGN] <-
417:[ID] option
417:[LPAREN] (
417:[RPAREN] )
417:[SEMICOLON] ;
418:[ID] cells
418:[ASSIGN] <-
418:[LPAREN] (
418:[NEW] new
418:[TYPE] CellularAutomaton
418:[RPAREN] )
418:[DOT] .
418:[ID] init
418:[LPAREN] (
418:[ID] choice
418:[RPAREN] )
418:[SEMICOLON] ;
419:[ID] cells
419:[DOT] .
419:[ID] print
419:[LPAREN] (
419:[RPAREN] )
419:[SEMICOLON] ;
420:[WHILE] while
420:[ID] continue
420:[LOOP] loop
421:[IF] if
421:[ID] prompt
421:[LPAREN] (
421:[RPAREN] )
421:[THEN] then
422:[LBRACE] {
423:[ID] cells
423:[DOT] .
423:[ID] evolve
423:[LPAREN] (
423:[RPAREN] )
423:[SEMICOLON] ;
424:[ID] cells
424:[DOT] .
424:[ID] print
424:[LPAREN] (
424:[RPAREN] )
424:[SEMICOLON] ;
425:[RBRACE] }
426:[ELSE] else
427:[ID] continue
427:[ASSIGN] <-
427:[FALSE] false
428:[FI] fi
429:[POOL] pool
429:[SEMICOLON] ;
430:[RBRACE] }
431:[POOL] pool
431:[SEMICOLON] ;
432:[ID] self
432:[SEMICOLON] ;
433:[RBRACE] }
433:[RPAREN] )
433:[RPAREN] )
433:[SEMICOLON] ;
433:[RBRACE] }
434:[RBRACE] }
434:[SEMICOLON] ;
435:[RBRACE] }
435:[SEMICOLON] ;
