021:[CLASS] class
021:[TYPE] VarList
021:[INHERITS] inherits
021:[TYPE] IO
021:[LBRACE] {
022:[ID] isNil
022:[LPAREN] (
022:[RPAREN] )
022:[COLON] :
022:[TYPE] Bool
022:[LBRACE] {
022:[TRUE] true
022:[RBRACE] }
022:[SEMICOLON] ;
023:[ID] head
023:[LPAREN] (
023:[RPAREN] )
023:[COLON] :
023:[TYPE] Variable
023:[LBRACE] {
023:[LBRACE] {
023:[ID] abort
023:[LPAREN] (
023:[RPAREN] )
023:[SEMICOLON] ;
023:[NEW] new
023:[TYPE] Variable
023:[SEMICOLON] ;
023:[RBRACE] }
023:[RBRACE] }
023:[SEMICOLON] ;
024:[ID] tail
024:[LPAREN] (
024:[RPAREN] )
024:[COLON] :
024:[TYPE] VarList
024:[LBRACE] {
024:[LBRACE] {
024:[ID] abort
024:[LPAREN] (
024:[RPAREN] )
024:[SEMICOLON] ;
024:[NEW] new
024:[TYPE] VarList
024:[SEMICOLON] ;
024:[RBRACE] }
024:[RBRACE] }
024:[SEMICOLON] ;
025:[ID] add
025:[LPAREN] (
025:[ID] x
025:[COLON] :
025:[TYPE] Variable
025:[RPAREN] )
025:[COLON] :
025:[TYPE] VarList
025:[LBRACE] {
025:[LPAREN] (
025:[NEW] new
025:[TYPE] VarListNE
025:[RPAREN] )
025:[DOT] .
025:[ID] init
025:[LPAREN] (
025:[ID] x
025:[COMMA] ,
025:[ID] self
025:[RPAREN] )
025:[RBRACE] }
025:[SEMICOLON] ;
026:[ID] print
026:[LPAREN] (
026:[RPAREN] )
026:[COLON] :
026:[TYPE] SELF_TYPE
026:[LBRACE] {
026:[ID] out_string
026:[LPAREN] (
026:[STRING] "\n"
026:[RPAREN] )
026:[RBRACE] }
026:[SEMICOLON] ;
027:[RBRACE] }
027:[SEMICOLON] ;
029:[CLASS] class
029:[TYPE] VarListNE
029:[INHERITS] inherits
029:[TYPE] VarList
029:[LBRACE] {
030:[ID] x
030:[COLON] :
030:[TYPE] Variable
030:[SEMICOLON] ;
031:[ID] rest
031:[COLON] :
031:[TYPE] VarList
031:[SEMICOLON] ;
032:[ID] isNil
032:[LPAREN] (
032:[RPAREN] )
032:[COLON] :
032:[TYPE] Bool
032:[LBRACE] {
032:[FALSE] false
032:[RBRACE] }
032:[SEMICOLON] ;
033:[ID] head
033:[LPAREN] (
033:[RPAREN] )
033:[COLON] :
033:[TYPE] Variable
033:[LBRACE] {
033:[ID] x
033:[RBRACE] }
033:[SEMICOLON] ;
034:[ID] tail
034:[LPAREN] (
034:[RPAREN] )
034:[COLON] :
034:[TYPE] VarList
034:[LBRACE] {
034:[ID] rest
034:[RBRACE] }
034:[SEMICOLON] ;
035:[ID] init
035:[LPAREN] (
035:[ID] y
035:[COLON] :
035:[TYPE] Variable
035:[COMMA] ,
035:[ID] r
035:[COLON] :
035:[TYPE] VarList
035:[RPAREN] )
035:[COLON] :
035:[TYPE] VarListNE
035:[LBRACE] {
035:[LBRACE] {
035:[ID] x
035:[ASSIGN] <-
035:[ID] y
035:[SEMICOLON] ;
035:[ID] rest
035:[ASSIGN] <-
035:[ID] r
035:[SEMICOLON] ;
035:[ID] self
035:[SEMICOLON] ;
035:[RBRACE] }
035:[RBRACE] }
035:[SEMICOLON] ;
036:[ID] print
036:[LPAREN] (
036:[RPAREN] )
036:[COLON] :
036:[TYPE] SELF_TYPE
036:[LBRACE] {
036:[LBRACE] {
036:[ID] x
036:[DOT] .
036:[ID] print_self
036:[LPAREN] (
036:[RPAREN] )
036:[SEMICOLON] ;
036:[ID] out_string
036:[LPAREN] (
036:[STRING] " "
036:[RPAREN] )
036:[SEMICOLON] ;
037:[ID] rest
037:[DOT] .
037:[ID] print
037:[LPAREN] (
037:[RPAREN] )
037:[SEMICOLON] ;
037:[ID] self
037:[SEMICOLON] ;
037:[RBRACE] }
037:[RBRACE] }
037:[SEMICOLON] ;
038:[RBRACE] }
038:[SEMICOLON] ;
044:[CLASS] class
044:[TYPE] LambdaList
044:[LBRACE] {
045:[ID] isNil
045:[LPAREN] (
045:[RPAREN] )
045:[COLON] :
045:[TYPE] Bool
045:[LBRACE] {
045:[TRUE] true
045:[RBRACE] }
045:[SEMICOLON] ;
046:[ID] headE
046:[LPAREN] (
046:[RPAREN] )
046:[COLON] :
046:[TYPE] VarList
046:[LBRACE] {
046:[LBRACE] {
046:[ID] abort
046:[LPAREN] (
046:[RPAREN] )
046:[SEMICOLON] ;
046:[NEW] new
046:[TYPE] VarList
046:[SEMICOLON] ;
046:[RBRACE] }
046:[RBRACE] }
046:[SEMICOLON] ;
047:[ID] headC
047:[LPAREN] (
047:[RPAREN] )
047:[COLON] :
047:[TYPE] Lambda
047:[LBRACE] {
047:[LBRACE] {
047:[ID] abort
047:[LPAREN] (
047:[RPAREN] )
047:[SEMICOLON] ;
047:[NEW] new
047:[TYPE] Lambda
047:[SEMICOLON] ;
047:[RBRACE] }
047:[RBRACE] }
047:[SEMICOLON] ;
048:[ID] headN
048:[LPAREN] (
048:[RPAREN] )
048:[COLON] :
048:[TYPE] Int
048:[LBRACE] {
048:[LBRACE] {
048:[ID] abort
048:[LPAREN] (
048:[RPAREN] )
048:[SEMICOLON] ;
048:[INTEGER] 0
048:[SEMICOLON] ;
048:[RBRACE] }
048:[RBRACE] }
048:[SEMICOLON] ;
049:[ID] tail
049:[LPAREN] (
049:[RPAREN] )
049:[COLON] :
049:[TYPE] LambdaList
049:[LBRACE] {
049:[LBRACE] {
049:[ID] abort
049:[LPAREN] (
049:[RPAREN] )
049:[SEMICOLON] ;
049:[NEW] new
049:[TYPE] LambdaList
049:[SEMICOLON] ;
049:[RBRACE] }
049:[RBRACE] }
049:[SEMICOLON] ;
050:[ID] add
050:[LPAREN] (
050:[ID] e
050:[COLON] :
050:[TYPE] VarList
050:[COMMA] ,
050:[ID] x
050:[COLON] :
050:[TYPE] Lambda
050:[COMMA] ,
050:[ID] n
050:[COLON] :
050:[TYPE] Int
050:[RPAREN] )
050:[COLON] :
050:[TYPE] LambdaList
050:[LBRACE] {
051:[LPAREN] (
051:[NEW] new
051:[TYPE] LambdaListNE
051:[RPAREN] )
051:[DOT] .
051:[ID] init
051:[LPAREN] (
051:[ID] e
051:[COMMA] ,
051:[ID] x
051:[COMMA] ,
051:[ID] n
051:[COMMA] ,
051:[ID] self
051:[RPAREN] )
052:[RBRACE] }
052:[SEMICOLON] ;
053:[RBRACE] }
053:[SEMICOLON] ;
055:[CLASS] class
055:[TYPE] LambdaListNE
055:[INHERITS] inherits
055:[TYPE] LambdaList
055:[LBRACE] {
056:[ID] lam
056:[COLON] :
056:[TYPE] Lambda
056:[SEMICOLON] ;
057:[ID] num
057:[COLON] :
057:[TYPE] Int
057:[SEMICOLON] ;
058:[ID] env
058:[COLON] :
058:[TYPE] VarList
058:[SEMICOLON] ;
059:[ID] rest
059:[COLON] :
059:[TYPE] LambdaList
059:[SEMICOLON] ;
060:[ID] isNil
060:[LPAREN] (
060:[RPAREN] )
060:[COLON] :
060:[TYPE] Bool
060:[LBRACE] {
060:[FALSE] false
060:[RBRACE] }
060:[SEMICOLON] ;
061:[ID] headE
061:[LPAREN] (
061:[RPAREN] )
061:[COLON] :
061:[TYPE] VarList
061:[LBRACE] {
061:[ID] env
061:[RBRACE] }
061:[SEMICOLON] ;
062:[ID] headC
062:[LPAREN] (
062:[RPAREN] )
062:[COLON] :
062:[TYPE] Lambda
062:[LBRACE] {
062:[ID] lam
062:[RBRACE] }
062:[SEMICOLON] ;
063:[ID] headN
063:[LPAREN] (
063:[RPAREN] )
063:[COLON] :
063:[TYPE] Int
063:[LBRACE] {
063:[ID] num
063:[RBRACE] }
063:[SEMICOLON] ;
064:[ID] tail
064:[LPAREN] (
064:[RPAREN] )
064:[COLON] :
064:[TYPE] LambdaList
064:[LBRACE] {
064:[ID] rest
064:[RBRACE] }
064:[SEMICOLON] ;
065:[ID] init
065:[LPAREN] (
065:[ID] e
065:[COLON] :
065:[TYPE] VarList
065:[COMMA] ,
065:[ID] l
065:[COLON] :
065:[TYPE] Lambda
065:[COMMA] ,
065:[ID] n
065:[COLON] :
065:[TYPE] Int
065:[COMMA] ,
065:[ID] r
065:[COLON] :
065:[TYPE] LambdaList
065:[RPAREN] )
065:[COLON] :
065:[TYPE] LambdaListNE
065:[LBRACE] {
066:[LBRACE] {
067:[ID] env
067:[ASSIGN] <-
067:[ID] e
067:[SEMICOLON] ;
068:[ID] lam
068:[ASSIGN] <-
068:[ID] l
068:[SEMICOLON] ;
069:[ID] num
069:[ASSIGN] <-
069:[ID] n
069:[SEMICOLON] ;
070:[ID] rest
070:[ASSIGN] <-
070:[ID] r
070:[SEMICOLON] ;
071:[ID] self
071:[SEMICOLON] ;
072:[RBRACE] }
073:[RBRACE] }
073:[SEMICOLON] ;
074:[RBRACE] }
074:[SEMICOLON] ;
076:[CLASS] class
076:[TYPE] LambdaListRef
076:[LBRACE] {
077:[ID] nextNum
077:[COLON] :
077:[TYPE] Int
077:[ASSIGN] <-
077:[INTEGER] 0
077:[SEMICOLON] ;
078:[ID] l
078:[COLON] :
078:[TYPE] LambdaList
078:[SEMICOLON] ;
079:[ID] isNil
079:[LPAREN] (
079:[RPAREN] )
079:[COLON] :
079:[TYPE] Bool
079:[LBRACE] {
079:[ID] l
079:[DOT] .
079:[ID] isNil
079:[LPAREN] (
079:[RPAREN] )
079:[RBRACE] }
079:[SEMICOLON] ;
080:[ID] headE
080:[LPAREN] (
080:[RPAREN] )
080:[COLON] :
080:[TYPE] VarList
080:[LBRACE] {
080:[ID] l
080:[DOT] .
080:[ID] headE
080:[LPAREN] (
080:[RPAREN] )
080:[RBRACE] }
080:[SEMICOLON] ;
081:[ID] headC
081:[LPAREN] (
081:[RPAREN] )
081:[COLON] :
081:[TYPE] Lambda
081:[LBRACE] {
081:[ID] l
081:[DOT] .
081:[ID] headC
081:[LPAREN] (
081:[RPAREN] )
081:[RBRACE] }
081:[SEMICOLON] ;
082:[ID] headN
082:[LPAREN] (
082:[RPAREN] )
082:[COLON] :
082:[TYPE] Int
082:[LBRACE] {
082:[ID] l
082:[DOT] .
082:[ID] headN
082:[LPAREN] (
082:[RPAREN] )
082:[RBRACE] }
082:[SEMICOLON] ;
083:[ID] reset
083:[LPAREN] (
083:[RPAREN] )
083:[COLON] :
083:[TYPE] SELF_TYPE
083:[LBRACE] {
084:[LBRACE] {
085:[ID] nextNum
085:[ASSIGN] <-
085:[INTEGER] 0
085:[SEMICOLON] ;
086:[ID] l
086:[ASSIGN] <-
086:[NEW] new
086:[TYPE] LambdaList
086:[SEMICOLON] ;
087:[ID] self
087:[SEMICOLON] ;
088:[RBRACE] }
089:[RBRACE] }
089:[SEMICOLON] ;
090:[ID] add
090:[LPAREN] (
090:[ID] env
090:[COLON] :
090:[TYPE] VarList
090:[COMMA] ,
090:[ID] c
090:[COLON] :
090:[TYPE] Lambda
090:[RPAREN] )
090:[COLON] :
090:[TYPE] Int
090:[LBRACE] {
091:[LBRACE] {
092:[ID] l
092:[ASSIGN] <-
092:[ID] l
092:[DOT] .
092:[ID] add
092:[LPAREN] (
092:[ID] env
092:[COMMA] ,
092:[ID] c
092:[COMMA] ,
092:[ID] nextNum
092:[RPAREN] )
092:[SEMICOLON] ;
093:[ID] nextNum
093:[ASSIGN] <-
093:[ID] nextNum
093:[PLUS] +
093:[INTEGER] 1
093:[SEMICOLON] ;
094:[ID] nextNum
094:[MINUS] -
094:[INTEGER] 1
094:[SEMICOLON] ;
095:[RBRACE] }
096:[RBRACE] }
096:[SEMICOLON] ;
097:[ID] removeHead
097:[LPAREN] (
097:[RPAREN] )
097:[COLON] :
097:[TYPE] SELF_TYPE
097:[LBRACE] {
098:[LBRACE] {
099:[ID] l
099:[ASSIGN] <-
099:[ID] l
099:[DOT] .
099:[ID] tail
099:[LPAREN] (
099:[RPAREN] )
099:[SEMICOLON] ;
100:[ID] self
100:[SEMICOLON] ;
101:[RBRACE] }
102:[RBRACE] }
102:[SEMICOLON] ;
103:[RBRACE] }
103:[SEMICOLON] ;
111:[CLASS] class
111:[TYPE] Expr
111:[INHERITS] inherits
111:[TYPE] IO
111:[LBRACE] {
114:[ID] print_self
114:[LPAREN] (
114:[RPAREN] )
114:[COLON] :
114:[TYPE] SELF_TYPE
114:[LBRACE] {
115:[LBRACE] {
116:[ID] out_string
116:[LPAREN] (
116:[STRING] "\nError: Expr is pure virtual; can't print self\n"
116:[RPAREN] )
116:[SEMICOLON] ;
117:[ID] abort
117:[LPAREN] (
117:[RPAREN] )
117:[SEMICOLON] ;
118:[ID] self
118:[SEMICOLON] ;
119:[RBRACE] }
120:[RBRACE] }
120:[SEMICOLON] ;
123:[ID] beta
123:[LPAREN] (
123:[RPAREN] )
123:[COLON] :
123:[TYPE] Expr
123:[LBRACE] {
124:[LBRACE] {
125:[ID] out_string
125:[LPAREN] (
125:[STRING] "\nError: Expr is pure virtual; can't beta-reduce\n"
125:[RPAREN] )
125:[SEMICOLON] ;
126:[ID] abort
126:[LPAREN] (
126:[RPAREN] )
126:[SEMICOLON] ;
127:[ID] self
127:[SEMICOLON] ;
128:[RBRACE] }
129:[RBRACE] }
129:[SEMICOLON] ;
132:[ID] substitute
132:[LPAREN] (
132:[ID] x
132:[COLON] :
132:[TYPE] Variable
132:[COMMA] ,
132:[ID] e
132:[COLON] :
132:[TYPE] Expr
132:[RPAREN] )
132:[COLON] :
132:[TYPE] Expr
132:[LBRACE] {
133:[LBRACE] {
134:[ID] out_string
134:[LPAREN] (
134:[STRING] "\nError: Expr is pure virtual; can't substitute\n"
134:[RPAREN] )
134:[SEMICOLON] ;
135:[ID] abort
135:[LPAREN] (
135:[RPAREN] )
135:[SEMICOLON] ;
136:[ID] self
136:[SEMICOLON] ;
137:[RBRACE] }
138:[RBRACE] }
138:[SEMICOLON] ;
141:[ID] gen_code
141:[LPAREN] (
141:[ID] env
141:[COLON] :
141:[TYPE] VarList
141:[COMMA] ,
141:[ID] closures
141:[COLON] :
141:[TYPE] LambdaListRef
141:[RPAREN] )
141:[COLON] :
141:[TYPE] SELF_TYPE
141:[LBRACE] {
142:[LBRACE] {
143:[ID] out_string
143:[LPAREN] (
143:[STRING] "\nError: Expr is pure virtual; can't gen_code\n"
143:[RPAREN] )
143:[SEMICOLON] ;
144:[ID] abort
144:[LPAREN] (
144:[RPAREN] )
144:[SEMICOLON] ;
145:[ID] self
145:[SEMICOLON] ;
146:[RBRACE] }
147:[RBRACE] }
147:[SEMICOLON] ;
148:[RBRACE] }
148:[SEMICOLON] ;
153:[CLASS] class
153:[TYPE] Variable
153:[INHERITS] inherits
153:[TYPE] Expr
153:[LBRACE] {
154:[ID] name
154:[COLON] :
154:[TYPE] String
154:[SEMICOLON] ;
156:[ID] init
156:[LPAREN] (
156:[ID] n
156:[COLON] :
156:[TYPE] String
156:[RPAREN] )
156:[COLON] :
156:[TYPE] Variable
156:[LBRACE] {
157:[LBRACE] {
158:[ID] name
158:[ASSIGN] <-
158:[ID] n
158:[SEMICOLON] ;
159:[ID] self
159:[SEMICOLON] ;
160:[RBRACE] }
161:[RBRACE] }
161:[SEMICOLON] ;
163:[ID] print_self
163:[LPAREN] (
163:[RPAREN] )
163:[COLON] :
163:[TYPE] SELF_TYPE
163:[LBRACE] {
164:[ID] out_string
164:[LPAREN] (
164:[ID] name
164:[RPAREN] )
165:[RBRACE] }
165:[SEMICOLON] ;
167:[ID] beta
167:[LPAREN] (
167:[RPAREN] )
167:[COLON] :
167:[TYPE] Expr
167:[LBRACE] {
167:[ID] self
167:[RBRACE] }
167:[SEMICOLON] ;
169:[ID] substitute
169:[LPAREN] (
169:[ID] x
169:[COLON] :
169:[TYPE] Variable
169:[COMMA] ,
169:[ID] e
169:[COLON] :
169:[TYPE] Expr
169:[RPAREN] )
169:[COLON] :
169:[TYPE] Expr
169:[LBRACE] {
170:[IF] if
170:[ID] x
170:[EQUAL] =
170:[ID] self
170:[THEN] then
170:[ID] e
170:[ELSE] else
170:[ID] self
170:[FI] fi
171:[RBRACE] }
171:[SEMICOLON] ;
173:[ID] gen_code
173:[LPAREN] (
173:[ID] env
173:[COLON] :
173:[TYPE] VarList
173:[COMMA] ,
173:[ID] closures
173:[COLON] :
173:[TYPE] LambdaListRef
173:[RPAREN] )
173:[COLON] :
173:[TYPE] SELF_TYPE
173:[LBRACE] {
174:[LET] let
174:[ID] cur_env
174:[COLON] :
174:[TYPE] VarList
174:[ASSIGN] <-
174:[ID] env
174:[IN] in
175:[LBRACE] {
175:[WHILE] while
175:[LPAREN] (
175:[IF] if
175:[ID] cur_env
175:[DOT] .
175:[ID] isNil
175:[LPAREN] (
175:[RPAREN] )
175:[THEN] then
176:[FALSE] false
177:[ELSE] else
178:[NOT] not
178:[LPAREN] (
178:[ID] cur_env
178:[DOT] .
178:[ID] head
178:[LPAREN] (
178:[RPAREN] )
178:[EQUAL] =
178:[ID] self
178:[RPAREN] )
179:[FI] fi
179:[RPAREN] )
179:[LOOP] loop
180:[LBRACE] {
180:[ID] out_string
180:[LPAREN] (
180:[STRING] "get_parent()."
180:[RPAREN] )
180:[SEMICOLON] ;
181:[ID] cur_env
181:[ASSIGN] <-
181:[ID] cur_env
181:[DOT] .
181:[ID] tail
181:[LPAREN] (
181:[RPAREN] )
181:[SEMICOLON] ;
182:[RBRACE] }
183:[POOL] pool
183:[SEMICOLON] ;
184:[IF] if
184:[ID] cur_env
184:[DOT] .
184:[ID] isNil
184:[LPAREN] (
184:[RPAREN] )
184:[THEN] then
185:[LBRACE] {
185:[ID] out_string
185:[LPAREN] (
185:[STRING] "Error:  free occurrence of "
185:[RPAREN] )
185:[SEMICOLON] ;
186:[ID] print_self
186:[LPAREN] (
186:[RPAREN] )
186:[SEMICOLON] ;
187:[ID] out_string
187:[LPAREN] (
187:[STRING] "\n"
187:[RPAREN] )
187:[SEMICOLON] ;
188:[ID] abort
188:[LPAREN] (
188:[RPAREN] )
188:[SEMICOLON] ;
189:[ID] self
189:[SEMICOLON] ;
190:[RBRACE] }
191:[ELSE] else
192:[ID] out_string
192:[LPAREN] (
192:[STRING] "get_x()"
192:[RPAREN] )
193:[FI] fi
193:[SEMICOLON] ;
194:[RBRACE] }
195:[RBRACE] }
195:[SEMICOLON] ;
196:[RBRACE] }
196:[SEMICOLON] ;
201:[CLASS] class
201:[TYPE] Lambda
201:[INHERITS] inherits
201:[TYPE] Expr
201:[LBRACE] {
202:[ID] arg
202:[COLON] :
202:[TYPE] Variable
202:[SEMICOLON] ;
203:[ID] body
203:[COLON] :
203:[TYPE] Expr
203:[SEMICOLON] ;
205:[ID] init
205:[LPAREN] (
205:[ID] a
205:[COLON] :
205:[TYPE] Variable
205:[COMMA] ,
205:[ID] b
205:[COLON] :
205:[TYPE] Expr
205:[RPAREN] )
205:[COLON] :
205:[TYPE] Lambda
205:[LBRACE] {
206:[LBRACE] {
207:[ID] arg
207:[ASSIGN] <-
207:[ID] a
207:[SEMICOLON] ;
208:[ID] body
208:[ASSIGN] <-
208:[ID] b
208:[SEMICOLON] ;
209:[ID] self
209:[SEMICOLON] ;
210:[RBRACE] }
211:[RBRACE] }
211:[SEMICOLON] ;
213:[ID] print_self
213:[LPAREN] (
213:[RPAREN] )
213:[COLON] :
213:[TYPE] SELF_TYPE
213:[LBRACE] {
214:[LBRACE] {
215:[ID] out_string
215:[LPAREN] (
215:[STRING] "\\"
215:[RPAREN] )
215:[SEMICOLON] ;
216:[ID] arg
216:[DOT] .
216:[ID] print_self
216:[LPAREN] (
216:[RPAREN] )
216:[SEMICOLON] ;
217:[ID] out_string
217:[LPAREN] (
217:[STRING] "."
217:[RPAREN] )
217:[SEMICOLON] ;
218:[ID] body
218:[DOT] .
218:[ID] print_self
218:[LPAREN] (
218:[RPAREN] )
218:[SEMICOLON] ;
219:[ID] self
219:[SEMICOLON] ;
220:[RBRACE] }
221:[RBRACE] }
221:[SEMICOLON] ;
223:[ID] beta
223:[LPAREN] (
223:[RPAREN] )
223:[COLON] :
223:[TYPE] Expr
223:[LBRACE] {
223:[ID] self
223:[RBRACE] }
223:[SEMICOLON] ;
225:[ID] apply
225:[LPAREN] (
225:[ID] actual
225:[COLON] :
225:[TYPE] Expr
225:[RPAREN] )
225:[COLON] :
225:[TYPE] Expr
225:[LBRACE] {
226:[ID] body
226:[DOT] .
226:[ID] substitute
226:[LPAREN] (
226:[ID] arg
226:[COMMA] ,
226:[ID] actual
226:[RPAREN] )
227:[RBRACE] }
227:[SEMICOLON] ;
230:[ID] substitute
230:[LPAREN] (
230:[ID] x
230:[COLON] :
230:[TYPE] Variable
230:[COMMA] ,
230:[ID] e
230:[COLON] :
230:[TYPE] Expr
230:[RPAREN] )
230:[COLON] :
230:[TYPE] Expr
230:[LBRACE] {
231:[IF] if
231:[ID] x
231:[EQUAL] =
231:[ID] arg
231:[THEN] then
232:[ID] self
233:[ELSE] else
234:[LET] let
234:[ID] new_body
234:[COLON] :
234:[TYPE] Expr
234:[ASSIGN] <-
234:[ID] body
234:[DOT] .
234:[ID] substitute
234:[LPAREN] (
234:[ID] x
234:[COMMA] ,
234:[ID] e
234:[RPAREN] )
234:[COMMA] ,
235:[ID] new_lam
235:[COLON] :
235:[TYPE] Lambda
235:[ASSIGN] <-
235:[NEW] new
235:[TYPE] Lambda
235:[IN] in
236:[ID] new_lam
236:[DOT] .
236:[ID] init
236:[LPAREN] (
236:[ID] arg
236:[COMMA] ,
236:[ID] new_body
236:[RPAREN] )
237:[FI] fi
238:[RBRACE] }
238:[SEMICOLON] ;
240:[ID] gen_code
240:[LPAREN] (
240:[ID] env
240:[COLON] :
240:[TYPE] VarList
240:[COMMA] ,
240:[ID] closures
240:[COLON] :
240:[TYPE] LambdaListRef
240:[RPAREN] )
240:[COLON] :
240:[TYPE] SELF_TYPE
240:[LBRACE] {
241:[LBRACE] {
242:[ID] out_string
242:[LPAREN] (
242:[STRING] "((new Closure"
242:[RPAREN] )
242:[SEMICOLON] ;
243:[ID] out_int
243:[LPAREN] (
243:[ID] closures
243:[DOT] .
243:[ID] add
243:[LPAREN] (
243:[ID] env
243:[COMMA] ,
243:[ID] self
243:[RPAREN] )
243:[RPAREN] )
243:[SEMICOLON] ;
244:[ID] out_string
244:[LPAREN] (
244:[STRING] ").init("
244:[RPAREN] )
244:[SEMICOLON] ;
245:[IF] if
245:[ID] env
245:[DOT] .
245:[ID] isNil
245:[LPAREN] (
245:[RPAREN] )
245:[THEN] then
246:[ID] out_string
246:[LPAREN] (
246:[STRING] "new Closure))"
246:[RPAREN] )
247:[ELSE] else
248:[ID] out_string
248:[LPAREN] (
248:[STRING] "self))"
248:[RPAREN] )
248:[FI] fi
248:[SEMICOLON] ;
249:[ID] self
249:[SEMICOLON] ;
250:[RBRACE] }
251:[RBRACE] }
251:[SEMICOLON] ;
253:[ID] gen_closure_code
253:[LPAREN] (
253:[ID] n
253:[COLON] :
253:[TYPE] Int
253:[COMMA] ,
253:[ID] env
253:[COLON] :
253:[TYPE] VarList
253:[COMMA] ,
254:[ID] closures
254:[COLON] :
254:[TYPE] LambdaListRef
254:[RPAREN] )
254:[COLON] :
254:[TYPE] SELF_TYPE
254:[LBRACE] {
255:[LBRACE] {
256:[ID] out_string
256:[LPAREN] (
256:[STRING] "class Closure"
256:[RPAREN] )
256:[SEMICOLON] ;
257:[ID] out_int
257:[LPAREN] (
257:[ID] n
257:[RPAREN] )
257:[SEMICOLON] ;
258:[ID] out_string
258:[LPAREN] (
258:[STRING] " inherits Closure {\n"
258:[RPAREN] )
258:[SEMICOLON] ;
259:[ID] out_string
259:[LPAREN] (
259:[STRING] "  apply(y : EvalObject) : EvalObject {\n"
259:[RPAREN] )
259:[SEMICOLON] ;
260:[ID] out_string
260:[LPAREN] (
260:[STRING] "    { out_string(\"Applying closure "
260:[RPAREN] )
260:[SEMICOLON] ;
261:[ID] out_int
261:[LPAREN] (
261:[ID] n
261:[RPAREN] )
261:[SEMICOLON] ;
262:[ID] out_string
262:[LPAREN] (
262:[STRING] "\\n\");\n"
262:[RPAREN] )
262:[SEMICOLON] ;
263:[ID] out_string
263:[LPAREN] (
263:[STRING] "      x <- y;\n"
263:[RPAREN] )
263:[SEMICOLON] ;
264:[ID] body
264:[DOT] .
264:[ID] gen_code
264:[LPAREN] (
264:[ID] env
264:[DOT] .
264:[ID] add
264:[LPAREN] (
264:[ID] arg
264:[RPAREN] )
264:[COMMA] ,
264:[ID] closures
264:[RPAREN] )
264:[SEMICOLON] ;
265:[ID] out_string
265:[LPAREN] (
265:[STRING] ";}};\n"
265:[RPAREN] )
265:[SEMICOLON] ;
266:[ID] out_string
266:[LPAREN] (
266:[STRING] "};\n"
266:[RPAREN] )
266:[SEMICOLON] ;
267:[RBRACE] }
268:[RBRACE] }
268:[SEMICOLON] ;
269:[RBRACE] }
269:[SEMICOLON] ;
274:[CLASS] class
274:[TYPE] App
274:[INHERITS] inherits
274:[TYPE] Expr
274:[LBRACE] {
275:[ID] fun
275:[COLON] :
275:[TYPE] Expr
275:[SEMICOLON] ;
276:[ID] arg
276:[COLON] :
276:[TYPE] Expr
276:[SEMICOLON] ;
278:[ID] init
278:[LPAREN] (
278:[ID] f
278:[COLON] :
278:[TYPE] Expr
278:[COMMA] ,
278:[ID] a
278:[COLON] :
278:[TYPE] Expr
278:[RPAREN] )
278:[COLON] :
278:[TYPE] App
278:[LBRACE] {
279:[LBRACE] {
280:[ID] fun
280:[ASSIGN] <-
280:[ID] f
280:[SEMICOLON] ;
281:[ID] arg
281:[ASSIGN] <-
281:[ID] a
281:[SEMICOLON] ;
282:[ID] self
282:[SEMICOLON] ;
283:[RBRACE] }
284:[RBRACE] }
284:[SEMICOLON] ;
286:[ID] print_self
286:[LPAREN] (
286:[RPAREN] )
286:[COLON] :
286:[TYPE] SELF_TYPE
286:[LBRACE] {
287:[LBRACE] {
288:[ID] out_string
288:[LPAREN] (
288:[STRING] "(("
288:[RPAREN] )
288:[SEMICOLON] ;
289:[ID] fun
289:[DOT] .
289:[ID] print_self
289:[LPAREN] (
289:[RPAREN] )
289:[SEMICOLON] ;
290:[ID] out_string
290:[LPAREN] (
290:[STRING] ")@("
290:[RPAREN] )
290:[SEMICOLON] ;
291:[ID] arg
291:[DOT] .
291:[ID] print_self
291:[LPAREN] (
291:[RPAREN] )
291:[SEMICOLON] ;
292:[ID] out_string
292:[LPAREN] (
292:[STRING] "))"
292:[RPAREN] )
292:[SEMICOLON] ;
293:[ID] self
293:[SEMICOLON] ;
294:[RBRACE] }
295:[RBRACE] }
295:[SEMICOLON] ;
297:[ID] beta
297:[LPAREN] (
297:[RPAREN] )
297:[COLON] :
297:[TYPE] Expr
297:[LBRACE] {
298:[CASE] case
298:[ID] fun
298:[OF] of
299:[ID] l
299:[COLON] :
299:[TYPE] Lambda
299:[DARROW] =>
299:[ID] l
299:[DOT] .
299:[ID] apply
299:[LPAREN] (
299:[ID] arg
299:[RPAREN] )
299:[SEMICOLON] ;
300:[ID] e
300:[COLON] :
300:[TYPE] Expr
300:[DARROW] =>
301:[LET] let
301:[ID] new_fun
301:[COLON] :
301:[TYPE] Expr
301:[ASSIGN] <-
301:[ID] fun
301:[DOT] .
301:[ID] beta
301:[LPAREN] (
301:[RPAREN] )
301:[COMMA] ,
302:[ID] new_app
302:[COLON] :
302:[TYPE] App
302:[ASSIGN] <-
302:[NEW] new
302:[TYPE] App
302:[IN] in
303:[ID] new_app
303:[DOT] .
303:[ID] init
303:[LPAREN] (
303:[ID] new_fun
303:[COMMA] ,
303:[ID] arg
303:[RPAREN] )
303:[SEMICOLON] ;
304:[ESAC] esac
305:[RBRACE] }
305:[SEMICOLON] ;
307:[ID] substitute
307:[LPAREN] (
307:[ID] x
307:[COLON] :
307:[TYPE] Variable
307:[COMMA] ,
307:[ID] e
307:[COLON] :
307:[TYPE] Expr
307:[RPAREN] )
307:[COLON] :
307:[TYPE] Expr
307:[LBRACE] {
308:[LET] let
308:[ID] new_fun
308:[COLON] :
308:[TYPE] Expr
308:[ASSIGN] <-
308:[ID] fun
308:[DOT] .
308:[ID] substitute
308:[LPAREN] (
308:[ID] x
308:[COMMA] ,
308:[ID] e
308:[RPAREN] )
308:[COMMA] ,
309:[ID] new_arg
309:[COLON] :
309:[TYPE] Expr
309:[ASSIGN] <-
309:[ID] arg
309:[DOT] .
309:[ID] substitute
309:[LPAREN] (
309:[ID] x
309:[COMMA] ,
309:[ID] e
309:[RPAREN] )
309:[COMMA] ,
310:[ID] new_app
310:[COLON] :
310:[TYPE] App
310:[ASSIGN] <-
310:[NEW] new
310:[TYPE] App
310:[IN] in
311:[ID] new_app
311:[DOT] .
311:[ID] init
311:[LPAREN] (
311:[ID] new_fun
311:[COMMA] ,
311:[ID] new_arg
311:[RPAREN] )
312:[RBRACE] }
312:[SEMICOLON] ;
314:[ID] gen_code
314:[LPAREN] (
314:[ID] env
314:[COLON] :
314:[TYPE] VarList
314:[COMMA] ,
314:[ID] closures
314:[COLON] :
314:[TYPE] LambdaListRef
314:[RPAREN] )
314:[COLON] :
314:[TYPE] SELF_TYPE
314:[LBRACE] {
315:[LBRACE] {
316:[ID] out_string
316:[LPAREN] (
316:[STRING] "(let x : EvalObject <- "
316:[RPAREN] )
316:[SEMICOLON] ;
317:[ID] fun
317:[DOT] .
317:[ID] gen_code
317:[LPAREN] (
317:[ID] env
317:[COMMA] ,
317:[ID] closures
317:[RPAREN] )
317:[SEMICOLON] ;
318:[ID] out_string
318:[LPAREN] (
318:[STRING] ",\n"
318:[RPAREN] )
318:[SEMICOLON] ;
319:[ID] out_string
319:[LPAREN] (
319:[STRING] "     y : EvalObject <- "
319:[RPAREN] )
319:[SEMICOLON] ;
320:[ID] arg
320:[DOT] .
320:[ID] gen_code
320:[LPAREN] (
320:[ID] env
320:[COMMA] ,
320:[ID] closures
320:[RPAREN] )
320:[SEMICOLON] ;
321:[ID] out_string
321:[LPAREN] (
321:[STRING] " in\n"
321:[RPAREN] )
321:[SEMICOLON] ;
322:[ID] out_string
322:[LPAREN] (
322:[STRING] "  case x of\n"
322:[RPAREN] )
322:[SEMICOLON] ;
323:[ID] out_string
323:[LPAREN] (
323:[STRING] "    c : Closure => c.apply(y);\n"
323:[RPAREN] )
323:[SEMICOLON] ;
324:[ID] out_string
324:[LPAREN] (
324:[STRING] "    o : Object => { abort(); new EvalObject; };\n"
324:[RPAREN] )
324:[SEMICOLON] ;
325:[ID] out_string
325:[LPAREN] (
325:[STRING] "  esac)"
325:[RPAREN] )
325:[SEMICOLON] ;
326:[RBRACE] }
327:[RBRACE] }
327:[SEMICOLON] ;
328:[RBRACE] }
328:[SEMICOLON] ;
335:[CLASS] class
335:[TYPE] Term
335:[INHERITS] inherits
335:[TYPE] IO
335:[LBRACE] {
339:[ID] var
339:[LPAREN] (
339:[ID] x
339:[COLON] :
339:[TYPE] String
339:[RPAREN] )
339:[COLON] :
339:[TYPE] Variable
339:[LBRACE] {
340:[LET] let
340:[ID] v
340:[COLON] :
340:[TYPE] Variable
340:[ASSIGN] <-
340:[NEW] new
340:[TYPE] Variable
340:[IN] in
341:[ID] v
341:[DOT] .
341:[ID] init
341:[LPAREN] (
341:[ID] x
341:[RPAREN] )
342:[RBRACE] }
342:[SEMICOLON] ;
344:[ID] lam
344:[LPAREN] (
344:[ID] x
344:[COLON] :
344:[TYPE] Variable
344:[COMMA] ,
344:[ID] e
344:[COLON] :
344:[TYPE] Expr
344:[RPAREN] )
344:[COLON] :
344:[TYPE] Lambda
344:[LBRACE] {
345:[LET] let
345:[ID] l
345:[COLON] :
345:[TYPE] Lambda
345:[ASSIGN] <-
345:[NEW] new
345:[TYPE] Lambda
345:[IN] in
346:[ID] l
346:[DOT] .
346:[ID] init
346:[LPAREN] (
346:[ID] x
346:[COMMA] ,
346:[ID] e
346:[RPAREN] )
347:[RBRACE] }
347:[SEMICOLON] ;
349:[ID] app
349:[LPAREN] (
349:[ID] e1
349:[COLON] :
349:[TYPE] Expr
349:[COMMA] ,
349:[ID] e2
349:[COLON] :
349:[TYPE] Expr
349:[RPAREN] )
349:[COLON] :
349:[TYPE] App
349:[LBRACE] {
350:[LET] let
350:[ID] a
350:[COLON] :
350:[TYPE] App
350:[ASSIGN] <-
350:[NEW] new
350:[TYPE] App
350:[IN] in
351:[ID] a
351:[DOT] .
351:[ID] init
351:[LPAREN] (
351:[ID] e1
351:[COMMA] ,
351:[ID] e2
351:[RPAREN] )
352:[RBRACE] }
352:[SEMICOLON] ;
357:[ID] i
357:[LPAREN] (
357:[RPAREN] )
357:[COLON] :
357:[TYPE] Expr
357:[LBRACE] {
358:[LET] let
358:[ID] x
358:[COLON] :
358:[TYPE] Variable
358:[ASSIGN] <-
358:[ID] var
358:[LPAREN] (
358:[STRING] "x"
358:[RPAREN] )
358:[IN] in
359:[ID] lam
359:[LPAREN] (
359:[ID] x
359:[COMMA] ,
359:[ID] x
359:[RPAREN] )
360:[RBRACE] }
360:[SEMICOLON] ;
362:[ID] k
362:[LPAREN] (
362:[RPAREN] )
362:[COLON] :
362:[TYPE] Expr
362:[LBRACE] {
363:[LET] let
363:[ID] x
363:[COLON] :
363:[TYPE] Variable
363:[ASSIGN] <-
363:[ID] var
363:[LPAREN] (
363:[STRING] "x"
363:[RPAREN] )
363:[COMMA] ,
364:[ID] y
364:[COLON] :
364:[TYPE] Variable
364:[ASSIGN] <-
364:[ID] var
364:[LPAREN] (
364:[STRING] "y"
364:[RPAREN] )
364:[IN] in
365:[ID] lam
365:[LPAREN] (
365:[ID] x
365:[COMMA] ,
365:[ID] lam
365:[LPAREN] (
365:[ID] y
365:[COMMA] ,
365:[ID] x
365:[RPAREN] )
365:[RPAREN] )
366:[RBRACE] }
366:[SEMICOLON] ;
368:[ID] s
368:[LPAREN] (
368:[RPAREN] )
368:[COLON] :
368:[TYPE] Expr
368:[LBRACE] {
369:[LET] let
369:[ID] x
369:[COLON] :
369:[TYPE] Variable
369:[ASSIGN] <-
369:[ID] var
369:[LPAREN] (
369:[STRING] "x"
369:[RPAREN] )
369:[COMMA] ,
370:[ID] y
370:[COLON] :
370:[TYPE] Variable
370:[ASSIGN] <-
370:[ID] var
370:[LPAREN] (
370:[STRING] "y"
370:[RPAREN] )
370:[COMMA] ,
371:[ID] z
371:[COLON] :
371:[TYPE] Variable
371:[ASSIGN] <-
371:[ID] var
371:[LPAREN] (
371:[STRING] "z"
371:[RPAREN] )
371:[IN] in
372:[ID] lam
372:[LPAREN] (
372:[ID] x
372:[COMMA] ,
372:[ID] lam
372:[LPAREN] (
372:[ID] y
372:[COMMA] ,
372:[ID] lam
372:[LPAREN] (
372:[ID] z
372:[COMMA] ,
372:[ID] app
372:[LPAREN] (
372:[ID] app
372:[LPAREN] (
372:[ID] x
372:[COMMA] ,
372:[ID] z
372:[RPAREN] )
372:[COMMA] ,
372:[ID] app
372:[LPAREN] (
372:[ID] y
372:[COMMA] ,
372:[ID] z
372:[RPAREN] )
372:[RPAREN] )
372:[RPAREN] )
372:[RPAREN] )
372:[RPAREN] )
373:[RBRACE] }
373:[SEMICOLON] ;
375:[RBRACE] }
375:[SEMICOLON] ;
383:[CLASS] class
383:[TYPE] Main
383:[INHERITS] inherits
383:[TYPE] Term
383:[LBRACE] {
385:[ID] beta_reduce
385:[LPAREN] (
385:[ID] e
385:[COLON] :
385:[TYPE] Expr
385:[RPAREN] )
385:[COLON] :
385:[TYPE] Expr
385:[LBRACE] {
386:[LBRACE] {
387:[ID] out_string
387:[LPAREN] (
387:[STRING] "beta-reduce: "
387:[RPAREN] )
387:[SEMICOLON] ;
388:[ID] e
388:[DOT] .
388:[ID] print_self
388:[LPAREN] (
388:[RPAREN] )
388:[SEMICOLON] ;
389:[LET] let
389:[ID] done
389:[COLON] :
389:[TYPE] Bool
389:[ASSIGN] <-
389:[FALSE] false
389:[COMMA] ,
390:[ID] new_expr
390:[COLON] :
390:[TYPE] Expr
390:[IN] in
391:[LBRACE] {
392:[WHILE] while
392:[LPAREN] (
392:[NOT] not
392:[ID] done
392:[RPAREN] )
392:[LOOP] loop
393:[LBRACE] {
394:[ID] new_expr
394:[ASSIGN] <-
394:[ID] e
394:[DOT] .
394:[ID] beta
394:[LPAREN] (
394:[RPAREN] )
394:[SEMICOLON] ;
395:[IF] if
395:[LPAREN] (
395:[ID] new_expr
395:[EQUAL] =
395:[ID] e
395:[RPAREN] )
395:[THEN] then
396:[ID] done
396:[ASSIGN] <-
396:[TRUE] true
397:[ELSE] else
398:[LBRACE] {
399:[ID] e
399:[ASSIGN] <-
399:[ID] new_expr
399:[SEMICOLON] ;
400:[ID] out_string
400:[LPAREN] (
400:[STRING] " =>\n"
400:[RPAREN] )
400:[SEMICOLON] ;
401:[ID] e
401:[DOT] .
401:[ID] print_self
401:[LPAREN] (
401:[RPAREN] )
401:[SEMICOLON] ;
402:[RBRACE] }
403:[FI] fi
403:[SEMICOLON] ;
404:[RBRACE] }
405:[POOL] pool
405:[SEMICOLON] ;
406:[ID] out_string
406:[LPAREN] (
406:[STRING] "\n"
406:[RPAREN] )
406:[SEMICOLON] ;
407:[ID] e
407:[SEMICOLON] ;
408:[RBRACE] }
408:[SEMICOLON] ;
409:[RBRACE] }
410:[RBRACE] }
410:[SEMICOLON] ;
412:[ID] eval_class
412:[LPAREN] (
412:[RPAREN] )
412:[COLON] :
412:[TYPE] SELF_TYPE
412:[LBRACE] {
413:[LBRACE] {
414:[ID] out_string
414:[LPAREN] (
414:[STRING] "class EvalObject inherits IO {\n"
414:[RPAREN] )
414:[SEMICOLON] ;
415:[ID] out_string
415:[LPAREN] (
415:[STRING] "  eval() : EvalObject { { abort(); self; } };\n"
415:[RPAREN] )
415:[SEMICOLON] ;
416:[ID] out_string
416:[LPAREN] (
416:[STRING] "};\n"
416:[RPAREN] )
416:[SEMICOLON] ;
417:[RBRACE] }
418:[RBRACE] }
418:[SEMICOLON] ;
420:[ID] closure_class
420:[LPAREN] (
420:[RPAREN] )
420:[COLON] :
420:[TYPE] SELF_TYPE
420:[LBRACE] {
421:[LBRACE] {
422:[ID] out_string
422:[LPAREN] (
422:[STRING] "class Closure inherits EvalObject {\n"
422:[RPAREN] )
422:[SEMICOLON] ;
423:[ID] out_string
423:[LPAREN] (
423:[STRING] "  parent : Closure;\n"
423:[RPAREN] )
423:[SEMICOLON] ;
424:[ID] out_string
424:[LPAREN] (
424:[STRING] "  x : EvalObject;\n"
424:[RPAREN] )
424:[SEMICOLON] ;
425:[ID] out_string
425:[LPAREN] (
425:[STRING] "  get_parent() : Closure { parent };\n"
425:[RPAREN] )
425:[SEMICOLON] ;
426:[ID] out_string
426:[LPAREN] (
426:[STRING] "  get_x() : EvalObject { x };\n"
426:[RPAREN] )
426:[SEMICOLON] ;
427:[ID] out_string
427:[LPAREN] (
427:[STRING] "  init(p : Closure) : Closure {{ parent <- p; self; }};\n"
427:[RPAREN] )
427:[SEMICOLON] ;
428:[ID] out_string
428:[LPAREN] (
428:[STRING] "  apply(y : EvalObject) : EvalObject { { abort(); self; } };\n"
428:[RPAREN] )
428:[SEMICOLON] ;
429:[ID] out_string
429:[LPAREN] (
429:[STRING] "};\n"
429:[RPAREN] )
429:[SEMICOLON] ;
430:[RBRACE] }
431:[RBRACE] }
431:[SEMICOLON] ;
433:[ID] gen_code
433:[LPAREN] (
433:[ID] e
433:[COLON] :
433:[TYPE] Expr
433:[RPAREN] )
433:[COLON] :
433:[TYPE] SELF_TYPE
433:[LBRACE] {
434:[LET] let
434:[ID] cl
434:[COLON] :
434:[TYPE] LambdaListRef
434:[ASSIGN] <-
434:[LPAREN] (
434:[NEW] new
434:[TYPE] LambdaListRef
434:[RPAREN] )
434:[DOT] .
434:[ID] reset
434:[LPAREN] (
434:[RPAREN] )
434:[IN] in
435:[LBRACE] {
436:[ID] out_string
436:[LPAREN] (
436:[STRING] "Generating code for "
436:[RPAREN] )
436:[SEMICOLON] ;
437:[ID] e
437:[DOT] .
437:[ID] print_self
437:[LPAREN] (
437:[RPAREN] )
437:[SEMICOLON] ;
438:[ID] out_string
438:[LPAREN] (
438:[STRING] "\n------------------cut here------------------\n"
438:[RPAREN] )
438:[SEMICOLON] ;
439:[ID] out_string
439:[LPAREN] (
439:[STRING] "(*Generated by lam.cl (Jeff Foster, March 2000)*)\n"
439:[RPAREN] )
439:[SEMICOLON] ;
440:[ID] eval_class
440:[LPAREN] (
440:[RPAREN] )
440:[SEMICOLON] ;
441:[ID] closure_class
441:[LPAREN] (
441:[RPAREN] )
441:[SEMICOLON] ;
442:[ID] out_string
442:[LPAREN] (
442:[STRING] "class Main {\n"
442:[RPAREN] )
442:[SEMICOLON] ;
443:[ID] out_string
443:[LPAREN] (
443:[STRING] "  main() : EvalObject {\n"
443:[RPAREN] )
443:[SEMICOLON] ;
444:[ID] e
444:[DOT] .
444:[ID] gen_code
444:[LPAREN] (
444:[NEW] new
444:[TYPE] VarList
444:[COMMA] ,
444:[ID] cl
444:[RPAREN] )
444:[SEMICOLON] ;
445:[ID] out_string
445:[LPAREN] (
445:[STRING] "\n};\n};\n"
445:[RPAREN] )
445:[SEMICOLON] ;
446:[WHILE] while
446:[LPAREN] (
446:[NOT] not
446:[LPAREN] (
446:[ID] cl
446:[DOT] .
446:[ID] isNil
446:[LPAREN] (
446:[RPAREN] )
446:[RPAREN] )
446:[RPAREN] )
446:[LOOP] loop
447:[LET] let
447:[ID] e
447:[COLON] :
447:[TYPE] VarList
447:[ASSIGN] <-
447:[ID] cl
447:[DOT] .
447:[ID] headE
447:[LPAREN] (
447:[RPAREN] )
447:[COMMA] ,
448:[ID] c
448:[COLON] :
448:[TYPE] Lambda
448:[ASSIGN] <-
448:[ID] cl
448:[DOT] .
448:[ID] headC
448:[LPAREN] (
448:[RPAREN] )
448:[COMMA] ,
449:[ID] n
449:[COLON] :
449:[TYPE] Int
449:[ASSIGN] <-
449:[ID] cl
449:[DOT] .
449:[ID] headN
449:[LPAREN] (
449:[RPAREN] )
449:[IN] in
450:[LBRACE] {
451:[ID] cl
451:[DOT] .
451:[ID] removeHead
451:[LPAREN] (
451:[RPAREN] )
451:[SEMICOLON] ;
452:[ID] c
452:[DOT] .
452:[ID] gen_closure_code
452:[LPAREN] (
452:[ID] n
452:[COMMA] ,
452:[ID] e
452:[COMMA] ,
452:[ID] cl
452:[RPAREN] )
452:[SEMICOLON] ;
453:[RBRACE] }
454:[POOL] pool
454:[SEMICOLON] ;
455:[ID] out_string
455:[LPAREN] (
455:[STRING] "\n------------------cut here------------------\n"
455:[RPAREN] )
455:[SEMICOLON] ;
456:[RBRACE] }
457:[RBRACE] }
457:[SEMICOLON] ;
459:[ID] main
459:[LPAREN] (
459:[RPAREN] )
459:[COLON] :
459:[TYPE] Int
459:[LBRACE] {
460:[LBRACE] {
461:[ID] i
461:[LPAREN] (
461:[RPAREN] )
461:[DOT] .
461:[ID] print_self
461:[LPAREN] (
461:[RPAREN] )
461:[SEMICOLON] ;
462:[ID] out_string
462:[LPAREN] (
462:[STRING] "\n"
462:[RPAREN] )
462:[SEMICOLON] ;
463:[ID] k
463:[LPAREN] (
463:[RPAREN] )
463:[DOT] .
463:[ID] print_self
463:[LPAREN] (
463:[RPAREN] )
463:[SEMICOLON] ;
464:[ID] out_string
464:[LPAREN] (
464:[STRING] "\n"
464:[RPAREN] )
464:[SEMICOLON] ;
465:[ID] s
465:[LPAREN] (
465:[RPAREN] )
465:[DOT] .
465:[ID] print_self
465:[LPAREN] (
465:[RPAREN] )
465:[SEMICOLON] ;
466:[ID] out_string
466:[LPAREN] (
466:[STRING] "\n"
466:[RPAREN] )
466:[SEMICOLON] ;
467:[ID] beta_reduce
467:[LPAREN] (
467:[ID] app
467:[LPAREN] (
467:[ID] app
467:[LPAREN] (
467:[ID] app
467:[LPAREN] (
467:[ID] s
467:[LPAREN] (
467:[RPAREN] )
467:[COMMA] ,
467:[ID] k
467:[LPAREN] (
467:[RPAREN] )
467:[RPAREN] )
467:[COMMA] ,
467:[ID] i
467:[LPAREN] (
467:[RPAREN] )
467:[RPAREN] )
467:[COMMA] ,
467:[ID] i
467:[LPAREN] (
467:[RPAREN] )
467:[RPAREN] )
467:[RPAREN] )
467:[SEMICOLON] ;
468:[ID] beta_reduce
468:[LPAREN] (
468:[ID] app
468:[LPAREN] (
468:[ID] app
468:[LPAREN] (
468:[ID] k
468:[LPAREN] (
468:[RPAREN] )
468:[COMMA] ,
468:[ID] i
468:[LPAREN] (
468:[RPAREN] )
468:[RPAREN] )
468:[COMMA] ,
468:[ID] i
468:[LPAREN] (
468:[RPAREN] )
468:[RPAREN] )
468:[RPAREN] )
468:[SEMICOLON] ;
469:[ID] gen_code
469:[LPAREN] (
469:[ID] app
469:[LPAREN] (
469:[ID] i
469:[LPAREN] (
469:[RPAREN] )
469:[COMMA] ,
469:[ID] i
469:[LPAREN] (
469:[RPAREN] )
469:[RPAREN] )
469:[RPAREN] )
469:[SEMICOLON] ;
470:[ID] gen_code
470:[LPAREN] (
470:[ID] app
470:[LPAREN] (
470:[ID] app
470:[LPAREN] (
470:[ID] app
470:[LPAREN] (
470:[ID] s
470:[LPAREN] (
470:[RPAREN] )
470:[COMMA] ,
470:[ID] k
470:[LPAREN] (
470:[RPAREN] )
470:[RPAREN] )
470:[COMMA] ,
470:[ID] i
470:[LPAREN] (
470:[RPAREN] )
470:[RPAREN] )
470:[COMMA] ,
470:[ID] i
470:[LPAREN] (
470:[RPAREN] )
470:[RPAREN] )
470:[RPAREN] )
470:[SEMICOLON] ;
471:[ID] gen_code
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] app
471:[LPAREN] (
471:[ID] i
471:[LPAREN] (
471:[RPAREN] )
471:[COMMA] ,
471:[ID] k
471:[LPAREN] (
471:[RPAREN] )
471:[RPAREN] )
471:[COMMA] ,
471:[ID] s
471:[LPAREN] (
471:[RPAREN] )
471:[RPAREN] )
471:[COMMA] ,
471:[ID] s
471:[LPAREN] (
471:[RPAREN] )
471:[RPAREN] )
471:[COMMA] ,
472:[ID] k
472:[LPAREN] (
472:[RPAREN] )
472:[RPAREN] )
472:[COMMA] ,
472:[ID] s
472:[LPAREN] (
472:[RPAREN] )
472:[RPAREN] )
472:[COMMA] ,
472:[ID] i
472:[LPAREN] (
472:[RPAREN] )
472:[RPAREN] )
472:[COMMA] ,
472:[ID] k
472:[LPAREN] (
472:[RPAREN] )
472:[RPAREN] )
472:[COMMA] ,
472:[ID] i
472:[LPAREN] (
472:[RPAREN] )
472:[RPAREN] )
472:[RPAREN] )
472:[SEMICOLON] ;
473:[ID] gen_code
473:[LPAREN] (
473:[ID] app
473:[LPAREN] (
473:[ID] app
473:[LPAREN] (
473:[ID] i
473:[LPAREN] (
473:[RPAREN] )
473:[COMMA] ,
473:[ID] app
473:[LPAREN] (
473:[ID] k
473:[LPAREN] (
473:[RPAREN] )
473:[COMMA] ,
473:[ID] s
473:[LPAREN] (
473:[RPAREN] )
473:[RPAREN] )
473:[RPAREN] )
473:[COMMA] ,
473:[ID] app
473:[LPAREN] (
473:[ID] k
473:[LPAREN] (
473:[RPAREN] )
473:[COMMA] ,
473:[ID] app
473:[LPAREN] (
473:[ID] s
473:[LPAREN] (
473:[RPAREN] )
473:[COMMA] ,
473:[ID] s
473:[LPAREN] (
473:[RPAREN] )
473:[RPAREN] )
473:[RPAREN] )
473:[RPAREN] )
473:[RPAREN] )
473:[SEMICOLON] ;
474:[INTEGER] 0
474:[SEMICOLON] ;
475:[RBRACE] }
476:[RBRACE] }
476:[SEMICOLON] ;
477:[RBRACE] }
477:[SEMICOLON] ;
