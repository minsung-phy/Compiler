005:[CLASS] class
005:[TYPE] CellularAutomaton
005:[INHERITS] inherits
005:[TYPE] IO
005:[LBRACE] {
006:[ID] population_map
006:[COLON] :
006:[TYPE] String
006:[SEMICOLON] ;
008:[ID] init
008:[LPAREN] (
008:[ID] map
008:[COLON] :
008:[TYPE] String
008:[RPAREN] )
008:[COLON] :
008:[TYPE] SELF_TYPE
008:[LBRACE] {
009:[LBRACE] {
010:[ID] population_map
010:[ASSIGN] <-
010:[ID] map
010:[SEMICOLON] ;
011:[ID] self
011:[SEMICOLON] ;
012:[RBRACE] }
013:[RBRACE] }
013:[SEMICOLON] ;
015:[ID] print
015:[LPAREN] (
015:[RPAREN] )
015:[COLON] :
015:[TYPE] SELF_TYPE
015:[LBRACE] {
016:[LBRACE] {
017:[ID] out_string
017:[LPAREN] (
017:[ID] population_map
017:[DOT] .
017:[ID] concat
017:[LPAREN] (
017:[STRING] "\n"
017:[RPAREN] )
017:[RPAREN] )
017:[SEMICOLON] ;
018:[ID] self
018:[SEMICOLON] ;
019:[RBRACE] }
020:[RBRACE] }
020:[SEMICOLON] ;
022:[ID] num_cells
022:[LPAREN] (
022:[RPAREN] )
022:[COLON] :
022:[TYPE] Int
022:[LBRACE] {
023:[ID] population_map
023:[DOT] .
023:[ID] length
023:[LPAREN] (
023:[RPAREN] )
024:[RBRACE] }
024:[SEMICOLON] ;
026:[ID] cell
026:[LPAREN] (
026:[ID] position
026:[COLON] :
026:[TYPE] Int
026:[RPAREN] )
026:[COLON] :
026:[TYPE] String
026:[LBRACE] {
027:[ID] population_map
027:[DOT] .
027:[ID] substr
027:[LPAREN] (
027:[ID] position
027:[COMMA] ,
027:[INTEGER] 1
027:[RPAREN] )
028:[RBRACE] }
028:[SEMICOLON] ;
030:[ID] cell_left_neighbor
030:[LPAREN] (
030:[ID] position
030:[COLON] :
030:[TYPE] Int
030:[RPAREN] )
030:[COLON] :
030:[TYPE] String
030:[LBRACE] {
031:[IF] if
031:[ID] position
031:[EQUAL] =
031:[INTEGER] 0
031:[THEN] then
032:[ID] cell
032:[LPAREN] (
032:[ID] num_cells
032:[LPAREN] (
032:[RPAREN] )
032:[MINUS] -
032:[INTEGER] 1
032:[RPAREN] )
033:[ELSE] else
034:[ID] cell
034:[LPAREN] (
034:[ID] position
034:[MINUS] -
034:[INTEGER] 1
034:[RPAREN] )
035:[FI] fi
036:[RBRACE] }
036:[SEMICOLON] ;
038:[ID] cell_right_neighbor
038:[LPAREN] (
038:[ID] position
038:[COLON] :
038:[TYPE] Int
038:[RPAREN] )
038:[COLON] :
038:[TYPE] String
038:[LBRACE] {
039:[IF] if
039:[ID] position
039:[EQUAL] =
039:[ID] num_cells
039:[LPAREN] (
039:[RPAREN] )
039:[MINUS] -
039:[INTEGER] 1
039:[THEN] then
040:[ID] cell
040:[LPAREN] (
040:[INTEGER] 0
040:[RPAREN] )
041:[ELSE] else
042:[ID] cell
042:[LPAREN] (
042:[ID] position
042:[PLUS] +
042:[INTEGER] 1
042:[RPAREN] )
043:[FI] fi
044:[RBRACE] }
044:[SEMICOLON] ;
048:[ID] cell_at_next_evolution
048:[LPAREN] (
048:[ID] position
048:[COLON] :
048:[TYPE] Int
048:[RPAREN] )
048:[COLON] :
048:[TYPE] String
048:[LBRACE] {
049:[IF] if
049:[LPAREN] (
049:[IF] if
049:[ID] cell
049:[LPAREN] (
049:[ID] position
049:[RPAREN] )
049:[EQUAL] =
049:[STRING] "X"
049:[THEN] then
049:[INTEGER] 1
049:[ELSE] else
049:[INTEGER] 0
049:[FI] fi
050:[PLUS] +
050:[IF] if
050:[ID] cell_left_neighbor
050:[LPAREN] (
050:[ID] position
050:[RPAREN] )
050:[EQUAL] =
050:[STRING] "X"
050:[THEN] then
050:[INTEGER] 1
050:[ELSE] else
050:[INTEGER] 0
050:[FI] fi
051:[PLUS] +
051:[IF] if
051:[ID] cell_right_neighbor
051:[LPAREN] (
051:[ID] position
051:[RPAREN] )
051:[EQUAL] =
051:[STRING] "X"
051:[THEN] then
051:[INTEGER] 1
051:[ELSE] else
051:[INTEGER] 0
051:[FI] fi
052:[EQUAL] =
052:[INTEGER] 1
052:[RPAREN] )
053:[THEN] then
054:[STRING] "X"
055:[ELSE] else
056:[STRING] "."
057:[FI] fi
058:[RBRACE] }
058:[SEMICOLON] ;
060:[ID] evolve
060:[LPAREN] (
060:[RPAREN] )
060:[COLON] :
060:[TYPE] SELF_TYPE
060:[LBRACE] {
061:[LPAREN] (
061:[LET] let
061:[ID] position
061:[COLON] :
061:[TYPE] Int
061:[IN] in
062:[LPAREN] (
062:[LET] let
062:[ID] num
062:[COLON] :
062:[TYPE] Int
062:[ASSIGN] <-
062:[ID] num_cells
062:[LPAREN] (
062:[RPAREN] )
062:[IN] in
063:[LPAREN] (
063:[LET] let
063:[ID] temp
063:[COLON] :
063:[TYPE] String
063:[IN] in
064:[LBRACE] {
065:[WHILE] while
065:[ID] position
065:[LT] <
065:[ID] num
065:[LOOP] loop
066:[LBRACE] {
067:[ID] temp
067:[ASSIGN] <-
067:[ID] temp
067:[DOT] .
067:[ID] concat
067:[LPAREN] (
067:[ID] cell_at_next_evolution
067:[LPAREN] (
067:[ID] position
067:[RPAREN] )
067:[RPAREN] )
067:[SEMICOLON] ;
068:[ID] position
068:[ASSIGN] <-
068:[ID] position
068:[PLUS] +
068:[INTEGER] 1
068:[SEMICOLON] ;
069:[RBRACE] }
070:[POOL] pool
070:[SEMICOLON] ;
071:[ID] population_map
071:[ASSIGN] <-
071:[ID] temp
071:[SEMICOLON] ;
072:[ID] self
072:[SEMICOLON] ;
073:[RBRACE] }
074:[RPAREN] )
074:[RPAREN] )
074:[RPAREN] )
075:[RBRACE] }
075:[SEMICOLON] ;
076:[RBRACE] }
076:[SEMICOLON] ;
078:[CLASS] class
078:[TYPE] Main
078:[LBRACE] {
079:[ID] cells
079:[COLON] :
079:[TYPE] CellularAutomaton
079:[SEMICOLON] ;
081:[ID] main
081:[LPAREN] (
081:[RPAREN] )
081:[COLON] :
081:[TYPE] SELF_TYPE
081:[LBRACE] {
082:[LBRACE] {
083:[ID] cells
083:[ASSIGN] <-
083:[LPAREN] (
083:[NEW] new
083:[TYPE] CellularAutomaton
083:[RPAREN] )
083:[DOT] .
083:[ID] init
083:[LPAREN] (
083:[STRING] "         X         "
083:[RPAREN] )
083:[SEMICOLON] ;
084:[ID] cells
084:[DOT] .
084:[ID] print
084:[LPAREN] (
084:[RPAREN] )
084:[SEMICOLON] ;
085:[LPAREN] (
085:[LET] let
085:[ID] countdown
085:[COLON] :
085:[TYPE] Int
085:[ASSIGN] <-
085:[INTEGER] 20
085:[IN] in
086:[WHILE] while
086:[INTEGER] 0
086:[LT] <
086:[ID] countdown
086:[LOOP] loop
087:[LBRACE] {
088:[ID] cells
088:[DOT] .
088:[ID] evolve
088:[LPAREN] (
088:[RPAREN] )
088:[SEMICOLON] ;
089:[ID] cells
089:[DOT] .
089:[ID] print
089:[LPAREN] (
089:[RPAREN] )
089:[SEMICOLON] ;
090:[ID] countdown
090:[ASSIGN] <-
090:[ID] countdown
090:[MINUS] -
090:[INTEGER] 1
090:[SEMICOLON] ;
091:[RBRACE] }
092:[POOL] pool
093:[RPAREN] )
093:[SEMICOLON] ;
094:[ID] self
094:[SEMICOLON] ;
095:[RBRACE] }
096:[RBRACE] }
096:[SEMICOLON] ;
097:[RBRACE] }
097:[SEMICOLON] ;
