008:[CLASS] Class
008:[TYPE] Main
008:[INHERITS] inheritS
008:[TYPE] IO
008:[LBRACE] {
009:[ID] main
009:[LPAREN] (
009:[RPAREN] )
009:[COLON] :
009:[TYPE] SELF_TYPE
009:[LBRACE] {
010:[LPAREN] (
010:[LET] let
010:[ID] c
010:[COLON] :
010:[TYPE] Complex
010:[ASSIGN] <-
010:[LPAREN] (
010:[NEW] new
010:[TYPE] Complex
010:[RPAREN] )
010:[DOT] .
010:[ID] init
010:[LPAREN] (
010:[INTEGER] 1
010:[COMMA] ,
010:[INTEGER] 1
010:[RPAREN] )
010:[IN] in
011:[LBRACE] {
013:[IF] If
013:[ID] c
013:[DOT] .
013:[ID] reflect_X
013:[LPAREN] (
013:[RPAREN] )
013:[EQUAL] =
013:[ID] c
013:[DOT] .
013:[ID] reflect_0
013:[LPAREN] (
013:[RPAREN] )
014:[THEN] then
014:[ID] out_string
014:[LPAREN] (
014:[STRING] "passed\n"
014:[RPAREN] )
015:[ELSE] ELSE
015:[ID] out_string
015:[LPAREN] (
015:[STRING] "failed\n"
015:[RPAREN] )
016:[FI] fi
016:[SEMICOLON] ;
018:[IF] if
018:[ID] c
018:[DOT] .
018:[ID] reflect_X
018:[LPAREN] (
018:[RPAREN] )
018:[DOT] .
018:[ID] reflect_Y
018:[LPAREN] (
018:[RPAREN] )
018:[DOT] .
018:[ID] equal
018:[LPAREN] (
018:[ID] c
018:[DOT] .
018:[ID] reflect_0
018:[LPAREN] (
018:[RPAREN] )
018:[RPAREN] )
019:[THEN] then
019:[ID] out_string
019:[LPAREN] (
019:[STRING] "passed\n"
019:[RPAREN] )
020:[ELSE] else
020:[ID] out_string
020:[LPAREN] (
020:[STRING] "스트링 출력은 \"와 같은 탈출문자를 올바르게 처리해야 한다."
020:[RPAREN] )
021:[FI] fi
021:[SEMICOLON] ;
022:[RBRACE] }
023:[RPAREN] )
024:[RBRACE] }
024:[SEMICOLON] ;
025:[RBRACE] }
025:[SEMICOLON] ;
